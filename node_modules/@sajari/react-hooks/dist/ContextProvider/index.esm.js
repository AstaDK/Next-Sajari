import { extends as _extends } from '../_virtual/_rollupPluginBabelHelpers.js';
import { isEmpty, isString, createContext } from '@sajari/react-sdk-utils';
import React__default, { useState, useRef, useCallback, useEffect } from 'react';
import { defaultConfig } from './Config.esm.js';
import { EVENT_SELECTION_UPDATED, EVENT_RANGE_UPDATED, EVENT_RESPONSE_UPDATED, EVENT_VALUES_UPDATED } from './events.esm.js';
import './controllers/Listener.esm.js';
import './controllers/analytics/Analytics.esm.js';
import './controllers/analytics/GoogleAnalytics.esm.js';
export { default as FilterBuilder } from './controllers/filters/FilterBuilder.esm.js';
export { default as RangeFilterBuilder } from './controllers/filters/RangeFilterBuilder.esm.js';
import combineFilters from './controllers/filters/combineFilters.esm.js';
export { default as combineFilters } from './controllers/filters/combineFilters.esm.js';
import { Response } from './controllers/Response.esm.js';
export { Response } from './controllers/Response.esm.js';
export { ClickTracking } from './controllers/tracking/ClickTracking.esm.js';
export { PosNegTracking } from './controllers/tracking/PosNegTracking.esm.js';
import { Pipeline } from './controllers/Pipeline.esm.js';
export { Pipeline } from './controllers/Pipeline.esm.js';
import { Variables } from './controllers/Variables.esm.js';
export { Variables } from './controllers/Variables.esm.js';
export { FieldDictionary } from './types.esm.js';

var updateState = function updateState(query, responseValues, config) {
  var completion = query && responseValues ? responseValues.get(config.qParam) || '' : '';
  var suggestions = [];

  if (responseValues) {
    suggestions = (responseValues.get(config.qSuggestionsParam) || '').split(',').filter(function (s) {
      return s.length > 0;
    }).slice(0, config.maxSuggestions);
  }

  return {
    completion: completion,
    query: query,
    suggestions: suggestions
  };
};

var responseUpdatedListener = function responseUpdatedListener(variables, config, response) {
  var query = variables.get()[config.qParam] || '';
  var responseValues = response.getValues();
  return updateState(query, responseValues, config);
};

var valuesUpdatedListener = function valuesUpdatedListener(variables, pipeline, config) {
  var query = variables.get()[config.qParam] || '';
  var responseValues = pipeline.getResponse().getValues();
  return updateState(query, responseValues, config);
};

var _createContext = /*#__PURE__*/createContext({
  strict: true,
  name: 'PipelineContext'
}),
    Provider = _createContext[0],
    useContext = _createContext[1];

var defaultState = {
  response: null,
  query: '',
  completion: '',
  suggestions: [],
  config: defaultConfig
};

var parseResponse = function parseResponse(initialResponse) {
  if (!isString(initialResponse) || isEmpty(initialResponse)) {
    return null;
  }

  var _JSON$parse = JSON.parse(initialResponse),
      _JSON$parse$queryValu = _JSON$parse.queryValues,
      queryValues = _JSON$parse$queryValu === void 0 ? {} : _JSON$parse$queryValu,
      _JSON$parse$response = _JSON$parse.response,
      response = _JSON$parse$response === void 0 ? {} : _JSON$parse$response,
      _JSON$parse$values = _JSON$parse.values,
      values = _JSON$parse$values === void 0 ? {} : _JSON$parse$values;

  return new Response(null, new Map(Object.entries(queryValues)), new Map(Object.entries(response)), new Map(Object.entries(values)));
};

var ContextProvider = function ContextProvider(_ref) {
  var _search$variables, _autocompleteProp$var;

  var children = _ref.children,
      search = _ref.search,
      autocompleteProp = _ref.autocomplete,
      defaultFilter = _ref.defaultFilter,
      searchOnLoad = _ref.searchOnLoad,
      initialResponseProp = _ref.initialResponse;
  var initialResponse = parseResponse(initialResponseProp);

  var _useState = useState(false),
      searching = _useState[0],
      setSearching = _useState[1];

  var _useState2 = useState(false),
      autocompleteSearching = _useState2[0],
      setAutocompleteSearching = _useState2[1];

  var _useState3 = useState(_extends({}, defaultState, {
    response: initialResponse
  })),
      searchState = _useState3[0],
      setSearchState = _useState3[1];

  var _useState4 = useState(defaultState),
      autocompleteState = _useState4[0],
      setAutocompleteState = _useState4[1];

  var _useState5 = useState(false),
      configDone = _useState5[0],
      setConfigDone = _useState5[1];

  var searchTimer = useRef();
  var searchAutocompleteTimer = useRef();
  var autocomplete = useRef(autocompleteProp);
  var variables = useRef((_search$variables = search.variables) != null ? _search$variables : new Variables());
  var autocompleteVariables = useRef((_autocompleteProp$var = autocompleteProp == null ? void 0 : autocompleteProp.variables) != null ? _autocompleteProp$var : new Variables());
  var response = search.pipeline.getResponse();

  if (response.isEmpty() && initialResponse !== null) {
    response = initialResponse;
  }

  if (!search.variables && !configDone) {
    Object.assign(search, {
      variables: variables.current
    });
  }

  if (autocompleteProp && !autocompleteProp.variables && !configDone) {
    Object.assign(autocompleteProp, {
      variables: autocompleteVariables.current
    });
  }

  if (!configDone) {
    var _search$filters, _variables$current$ge, _defaultFilter$toStri;

    var _filter = combineFilters((_search$filters = search.filters) != null ? _search$filters : []);

    var variablesFilterString = (_variables$current$ge = variables.current.get().filter) != null ? _variables$current$ge : '';
    var defaultFilterString = (_defaultFilter$toStri = defaultFilter == null ? void 0 : defaultFilter.toString()) != null ? _defaultFilter$toStri : '';
    variables.current.set({
      filter: function filter() {
        var expression = _filter.filter();

        return [defaultFilterString, variablesFilterString, isEmpty(expression) ? '_id != ""' : expression].filter(Boolean).join(' AND ');
      },
      countFilters: function countFilters() {
        return _filter.countFilters();
      },
      buckets: function buckets() {
        return _filter.buckets();
      },
      count: function count() {
        return _filter.count();
      },
      min: function min() {
        return _filter.min();
      },
      max: function max() {
        return _filter.max();
      }
    });
  }

  var searchFn = useCallback(function (key) {
    return function (inputQuery, override) {
      var _text;

      if (override === void 0) {
        override = false;
      }

      var func = key === 'autocomplete' ? autocomplete.current : search;
      var state = key === 'autocomplete' ? autocompleteState : searchState;
      var setSearchingState = key === 'autocomplete' ? setAutocompleteSearching : setSearching;
      var timer = key === 'autocomplete' ? searchAutocompleteTimer : searchTimer;
      setSearchingState(true);
      setSearchState(function (state) {
        return _extends({}, state, {
          query: inputQuery != null ? inputQuery : state.query
        });
      });
      var pipeline = func.pipeline,
          variables = func.variables;
      var config = state.config;
      var text = (_text = {}, _text[config.qParam] = inputQuery != null ? inputQuery : variables.get()[config.qParam], _text[config.qOverrideParam] = undefined, _text[config.pageParam] = undefined, _text);

      if (override) {
        text[config.qOverrideParam] = 'true';
      }

      variables.set(text);

      if (timer.current) {
        clearTimeout(timer.current);
      }

      timer.current = setTimeout(function () {
        pipeline.search(variables.get());
      }, 50);
    };
  }, []);
  useEffect(function () {
    var mergedConfig = _extends({}, defaultConfig, search.config);

    setSearchState(function (state) {
      return _extends({}, state, {
        response: response,
        query: variables.current.get()[mergedConfig.qParam] || '',
        config: mergedConfig
      });
    });
    setAutocompleteState(function (state) {
      return _extends({}, state, {
        config: _extends({}, defaultConfig, search.config)
      });
    });
    var unregisterFunctions = [];

    if (search.filters) {
      var filter = combineFilters(search.filters);
      unregisterFunctions.push(filter.listen(EVENT_SELECTION_UPDATED, function () {
        return searchFn('search')();
      }), filter.listen(EVENT_RANGE_UPDATED, function () {
        return searchFn('search')();
      }), filter.removeChildFilterListeners);
    }

    var searchRenderTimer;
    unregisterFunctions.push(search.pipeline.listen(EVENT_RESPONSE_UPDATED, function (response) {
      var _response$getResults;

      clearTimeout(searchRenderTimer);
      searchRenderTimer = setTimeout(function () {
        setSearching(false);
        setSearchState(function (prevState) {
          return _extends({}, prevState, {
            response: response
          }, responseUpdatedListener(variables.current, prevState.config, response));
        });
      }, ((_response$getResults = response.getResults()) == null ? void 0 : _response$getResults.length) === 0 ? 500 : 20);
    }));
    unregisterFunctions.push(variables.current.listen(EVENT_VALUES_UPDATED, function () {
      return setSearchState(function (prevState) {
        return _extends({}, prevState, valuesUpdatedListener(variables.current, search.pipeline, prevState.config));
      });
    }));

    if (!autocomplete.current) {
      var _search$pipeline$conf = search.pipeline.config,
          account = _search$pipeline$conf.account,
          collection = _search$pipeline$conf.collection,
          endpoint = _search$pipeline$conf.endpoint;
      autocomplete.current = {
        pipeline: new Pipeline({
          account: account,
          collection: collection,
          endpoint: endpoint
        }, 'autocomplete'),
        variables: autocompleteVariables.current
      };
    }

    unregisterFunctions.push(autocomplete.current.pipeline.listen(EVENT_RESPONSE_UPDATED, function (response) {
      setAutocompleteSearching(false);
      setAutocompleteState(function (prevState) {
        return _extends({}, prevState, {
          response: response
        }, responseUpdatedListener(autocompleteVariables.current, prevState.config, response));
      });
    }));
    unregisterFunctions.push(autocompleteVariables.current.listen(EVENT_VALUES_UPDATED, function () {
      return setAutocompleteState(function (prevState) {
        return _extends({}, prevState, valuesUpdatedListener(autocompleteVariables.current, autocomplete.current.pipeline, prevState.config));
      });
    }));

    if (searchOnLoad) {
      search.pipeline.search(variables.current.get());
    }

    setConfigDone(true);
    return function () {
      unregisterFunctions.forEach(function (fn) {
        return fn();
      });
    };
  }, []);
  var clear = useCallback(function (key) {
    return function (vals) {
      var func = key === 'autocomplete' ? autocomplete.current : search;
      var pipeline = func.pipeline,
          variables = func.variables;

      if (vals !== undefined) {
        variables.set(vals);
      }

      pipeline.clearResponse(variables.get());
    };
  }, []);
  var handlePaginate = useCallback(function (page) {
    var _variables$set;

    var pipeline = search.pipeline,
        variables = search.variables;
    var config = searchState.config;
    variables.set((_variables$set = {}, _variables$set[config.pageParam] = String(page), _variables$set));
    setSearching(true);
    pipeline.search(variables.get());
  }, [search.pipeline, search.variables, searchState.config]);
  var handleResultClicked = useCallback(function (url) {
    return search.pipeline.emitResultClicked(url);
  }, []);

  var getContext = function getContext(state) {
    var _autocomplete$current, _autocomplete$current2;

    return _extends({}, state, {
      search: _extends({}, state.search, {
        variables: variables.current,
        filters: search.filters,
        pipeline: search.pipeline,
        search: searchFn('search'),
        clear: clear('search'),
        fields: search.fields,
        searching: searching
      }),
      autocomplete: _extends({}, state.autocomplete, {
        variables: autocompleteVariables.current,
        filters: search.filters,
        pipeline: (_autocomplete$current = autocomplete.current) == null ? void 0 : _autocomplete$current.pipeline,
        search: searchFn('autocomplete'),
        clear: clear('autocomplete'),
        fields: (_autocomplete$current2 = autocomplete.current) == null ? void 0 : _autocomplete$current2.fields,
        searching: autocompleteSearching
      }),
      resultClicked: handleResultClicked,
      paginate: handlePaginate
    });
  };

  return React__default.createElement(Provider, {
    value: getContext({
      autocomplete: autocompleteState,
      search: searchState
    })
  }, children);
};

export default ContextProvider;
export { useContext };
//# sourceMappingURL=index.esm.js.map
