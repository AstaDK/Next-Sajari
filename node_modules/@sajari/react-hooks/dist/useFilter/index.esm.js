import { extends as _extends } from '../_virtual/_rollupPluginBabelHelpers.js';
import { useMemo, useState, useEffect } from 'react';
import { EVENT_SELECTION_UPDATED } from '../ContextProvider/events.esm.js';
import FilterBuilder from '../ContextProvider/controllers/filters/FilterBuilder.esm.js';
import { useContext } from '../ContextProvider/index.esm.js';
import '../utils/mapToObject.esm.js';
import { getBucketCount } from '../utils/response.esm.js';
import { sortItems } from './utils.esm.js';

function useFilter(name, params) {
  if (params === void 0) {
    params = {};
  }

  var _useContext = useContext(),
      _useContext$search = _useContext.search,
      _useContext$search$fi = _useContext$search.filters,
      filters = _useContext$search$fi === void 0 ? [] : _useContext$search$fi,
      response = _useContext$search.response;

  var filter = useMemo(function () {
    return filters.filter(function (f) {
      return f instanceof FilterBuilder && f.getName() === name;
    })[0];
  }, []);

  if (!filter) {
    throw new Error("Filter \"" + name + "\" doesn't exist.");
  }

  var _useState = useState(filter.get()),
      selected = _useState[0],
      setInternalSelected = _useState[1];

  useEffect(function () {
    var removeListener = filter.listen(EVENT_SELECTION_UPDATED, function () {
      setInternalSelected(filter.get());
    });
    return function () {
      removeListener();
    };
  }, []);

  var setSelected = function setSelected(value, merge) {
    if (merge === void 0) {
      merge = false;
    }

    filter.set(value, merge);
  };

  var reset = function reset() {
    filter.reset();
  };

  var _params = params,
      _params$sort = _params.sort,
      sort = _params$sort === void 0 ? 'alpha' : _params$sort,
      _params$sortAscending = _params.sortAscending,
      sortAscending = _params$sortAscending === void 0 ? sort !== 'count' : _params$sortAscending;
  var options = useMemo(function () {
    if (!response || (response == null ? void 0 : response.isEmpty())) {
      return [];
    }

    var aggregates = response.getAggregates();
    var aggregateFilters = response.getAggregateFilters();
    var isCount = filter.getCount();
    var field = filter.getField();

    if (isCount && field) {
      var array = filter.isArray();
      var count = {};

      var _ref = (aggregateFilters || {})[field] || {};

      count = _ref.count;

      if (!count) {
        var _ref2 = (aggregates || {})[field] || {};

        var _ref2$count = _ref2.count;
        count = _ref2$count === void 0 ? {} : _ref2$count;
      }

      var temp = sortItems(Object.entries(count), sort, sortAscending).map(function (_ref3) {
        var label = _ref3[0],
            count = _ref3[1];
        return {
          label: label,
          count: count,
          value: array ? field + " ~ [\"" + label + "\"]" : field + " = \"" + label + "\""
        };
      });
      filter.setOptions(temp.reduce(function (a, c) {
        var _extends2;

        return _extends({}, a, (_extends2 = {}, _extends2[c.label] = c.value, _extends2));
      }, {}));
      return temp;
    }

    return sortItems(Object.entries(filter.getOptions()), sort, sortAscending).map(function (_ref4) {
      var label = _ref4[0],
          value = _ref4[1];
      var id = name + "_" + label;
      var count = getBucketCount(response, id);
      return {
        label: label,
        value: value,
        count: count
      };
    });
  }, [JSON.stringify(response == null ? void 0 : response.getResults())]);
  return {
    options: options,
    setSelected: setSelected,
    selected: selected,
    reset: reset,
    multi: filter.isMulti()
  };
}

export default useFilter;
//# sourceMappingURL=index.esm.js.map
