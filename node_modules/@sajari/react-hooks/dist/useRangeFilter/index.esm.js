import { isNullOrUndefined } from '@sajari/react-sdk-utils';
import { useRef, useMemo, useState, useEffect, useCallback } from 'react';
import { EVENT_RANGE_UPDATED } from '../ContextProvider/events.esm.js';
import RangeFilterBuilder from '../ContextProvider/controllers/filters/RangeFilterBuilder.esm.js';
import { useContext } from '../ContextProvider/index.esm.js';

function useRangeFilter(name) {
  var _useContext = useContext(),
      _useContext$search = _useContext.search,
      _useContext$search$fi = _useContext$search.filters,
      filters = _useContext$search$fi === void 0 ? [] : _useContext$search$fi,
      response = _useContext$search.response,
      query = _useContext$search.query;

  var prevQuery = useRef(null);
  var selectionUpdated = useRef(false);
  var filter = useMemo(function () {
    return filters.filter(function (f) {
      return f instanceof RangeFilterBuilder && f.getName() === name;
    })[0];
  }, []);
  var isAggregate = filter.isAggregate();
  var limit = filter.getMinMax();

  if (!filter) {
    throw new Error("Filter \"" + name + "\" doesn't exist.");
  }

  var _useState = useState(filter.get()),
      range = _useState[0],
      setInternalRange = _useState[1];

  var _useState2 = useState(limit[0]),
      min = _useState2[0],
      setMin = _useState2[1];

  var _useState3 = useState(limit[1]),
      max = _useState3[0],
      setMax = _useState3[1];

  useEffect(function () {
    if (isAggregate && prevQuery.current !== null) {
      filter.reset(false);
    }
  }, [query]);
  useEffect(function () {
    var removeListener = filter.listen(EVENT_RANGE_UPDATED, function () {
      setInternalRange(filter.get());
    });
    return function () {
      removeListener();
    };
  }, []);
  var setRange = useCallback(function (value) {
    filter.set(value);
  }, []);
  var showReset = useMemo(function () {
    if (!range) {
      return false;
    }

    if (isAggregate) {
      return range[0] !== min || range[1] !== max;
    }

    return filter.hasChanged();
  }, [range, min, max]);

  var reset = function reset() {
    if (isAggregate) {
      filter.set([].concat(filter.getMinMax()));
    } else {
      filter.reset();
    }
  };

  useEffect(function () {
    if (!isAggregate || prevQuery.current === query || filter.getFrozen()) {
      prevQuery.current = query;
      return;
    }

    if (!response || (response == null ? void 0 : response.isEmpty())) {
      setMin(range ? range[0] : limit[0]);
      setMax(range ? range[1] : limit[1]);
      selectionUpdated.current = false;
      return;
    }

    var field = filter.getField();
    var aggregates = response.getAggregates();
    var aggregateFilters = response.getAggregateFilters();
    var newMin = 0;
    var newMax = 0;
    var aggregate = (aggregates || {})[field] || {};
    var aggregateFilter = (aggregateFilters || {})[field] || {};

    if (!isNullOrUndefined(aggregateFilter.min)) {
      newMin = aggregateFilter.min;
    } else if (!isNullOrUndefined(aggregate.min)) {
      newMin = aggregate.min;
    }

    if (!isNullOrUndefined(aggregateFilter.max)) {
      newMax = aggregateFilter.max;
    } else if (!isNullOrUndefined(aggregate.max)) {
      newMax = aggregate.max;
    }

    var _filter$format = filter.format([newMin, newMax]);

    newMin = _filter$format[0];
    newMax = _filter$format[1];
    setMin(newMin);
    setMax(newMax);
    filter.setMin(newMin);
    filter.setMax(newMax);
    filter.set([newMin, newMax], false);
    setInternalRange([newMin, newMax]);
    prevQuery.current = query;
  }, [JSON.stringify(response == null ? void 0 : response.getResults())]);
  return {
    min: min,
    max: max,
    step: filter.getStep(),
    setRange: setRange,
    range: range,
    reset: reset,
    showReset: showReset
  };
}

export default useRangeFilter;
//# sourceMappingURL=index.esm.js.map
