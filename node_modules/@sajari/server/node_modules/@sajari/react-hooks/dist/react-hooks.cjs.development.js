'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var reactSdkUtils = require('@sajari/react-sdk-utils');
var React = require('react');
var React__default = _interopDefault(React);
var sdkJs = require('@sajari/sdk-js');
var Cookies = _interopDefault(require('js-cookie'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var defaultConfig = {
  qParam: 'q',
  qOverrideParam: 'q.override',
  qSuggestionsParam: 'q.suggestions',
  resultsPerPageParam: 'resultsPerPage',
  pageParam: 'page',
  maxSuggestions: 10
};

var EVENT_SEARCH_SENT = 'search-sent';
var EVENT_RESPONSE_UPDATED = 'response-updated';
var EVENT_RESULT_CLICKED = 'result-clicked';
var EVENT_VALUES_UPDATED = 'values-changed';
var EVENT_TRACKING_RESET = 'tracking-reset';
var EVENT_ANALYTICS_PAGE_CLOSED = 'page-close-analytics';
var EVENT_ANALYTICS_BODY_RESET = 'body-reset-analytics';
var EVENT_ANALYTICS_RESULT_CLICKED = 'result-clicked-analytics';
var EVENT_SELECTION_UPDATED = 'selection-updated';
var EVENT_OPTIONS_UPDATED = 'options-updated';
var EVENT_RANGE_UPDATED = 'range-updated';

var Listener = /*#__PURE__*/function () {
  function Listener() {
    this.listeners = [];
  }

  var _proto = Listener.prototype;

  _proto.listen = function listen(callback) {
    var _this = this;

    this.listeners.push(callback);
    return function () {
      return _this.unlisten(callback);
    };
  };

  _proto.unlisten = function unlisten(callback) {
    var index = this.listeners.indexOf(callback);

    if (index >= 0) {
      this.listeners.splice(index, 1);
    }
  };

  _proto.notify = function notify(fn) {
    this.listeners.forEach(function (l) {
      try {
        fn(l);
      } catch (e) {
        if (console && console.error) {
          console.error(e);
        }
      }
    });
  };

  return Listener;
}();

var events = [EVENT_ANALYTICS_PAGE_CLOSED, EVENT_ANALYTICS_BODY_RESET, EVENT_ANALYTICS_RESULT_CLICKED];
var Analytics = /*#__PURE__*/function () {
  function Analytics(pipeline, tracking) {
    var _this = this,
        _Object$entries;

    this.beforeunload = function () {
      if (_this.enabled && _this.body) {
        _this.listeners.get(EVENT_ANALYTICS_PAGE_CLOSED).notify(function (callback) {
          callback(_this.body);
        });

        _this.enabled = false;
      }
    };

    this.resetBody = function () {
      if (_this.enabled) {
        _this.listeners.get(EVENT_ANALYTICS_BODY_RESET).notify(function (callback) {
          callback(_this.body);
        });

        _this.longestNonAutocompletedBody = '';
        _this.longestAutocompletedBody = '';
        _this.enabled = false;
      }
    };

    this.responseUpdated = function (response) {
      if (response.isEmpty() || response.isError()) {
        return;
      }

      _this.enabled = true;
      var originalBody = response.getQueryValues().get(_this.bodyLabel) || '';
      var responseBody = response.getValues().get(_this.bodyAutocompletedLabel) || originalBody;
      _this.body = responseBody;

      if (originalBody.length >= _this.longestNonAutocompletedBody.length) {
        _this.longestNonAutocompletedBody = originalBody;
        _this.longestAutocompletedBody = responseBody;
      }
    };

    this.resultClicked = function () {
      if (_this.enabled && _this.body) {
        _this.listeners.get(EVENT_ANALYTICS_RESULT_CLICKED).notify(function (callback) {
          callback(_this.body);
        });

        _this.longestNonAutocompletedBody = '';
        _this.longestAutocompletedBody = '';
        _this.enabled = false;
      }
    };

    this.enabled = false;
    this.body = '';
    this.pipeline = pipeline;
    this.tracking = tracking;
    this.listeners = new Map(Object.entries((_Object$entries = {}, _Object$entries[EVENT_ANALYTICS_PAGE_CLOSED] = new Listener(), _Object$entries[EVENT_ANALYTICS_BODY_RESET] = new Listener(), _Object$entries[EVENT_ANALYTICS_RESULT_CLICKED] = new Listener(), _Object$entries)));
    this.longestNonAutocompletedBody = '';
    this.longestAutocompletedBody = '';
    this.bodyLabel = 'q';
    this.bodyAutocompletedLabel = 'q';

    if (!reactSdkUtils.isSSR()) {
      window.addEventListener('beforeunload', this.beforeunload);
    }

    this.pipeline.listen(EVENT_RESPONSE_UPDATED, this.responseUpdated);
    this.pipeline.listen(EVENT_RESULT_CLICKED, this.resultClicked);
    this.tracking.listen(EVENT_TRACKING_RESET, this.resetBody);
  }

  var _proto = Analytics.prototype;

  _proto.listen = function listen(event, callback) {
    if (events.indexOf(event) === -1) {
      throw new Error("Unknown event type \"" + event + "\"");
    }

    return this.listeners.get(event).listen(callback);
  };

  return Analytics;
}();

var GoogleAnalyticsObjects;

(function (GoogleAnalyticsObjects) {
  GoogleAnalyticsObjects["UniversalAnalytics"] = "_ua";
  GoogleAnalyticsObjects["AnalyticsJS"] = "ga";
  GoogleAnalyticsObjects["GTag"] = "gtag";
})(GoogleAnalyticsObjects || (GoogleAnalyticsObjects = {}));

var url = {
  decodeUriArgs: function decodeUriArgs(queryStr) {
    var args = {};
    var a = queryStr.split('&');

    for (var i in a) {
      if (a.hasOwnProperty(i)) {
        var b = a[i].split('=');
        args[decodeURIComponent(b[0])] = decodeURIComponent(b[1]);
      }
    }

    return args;
  },
  encodeUriArgs: function encodeUriArgs(args) {
    var queryParts = [];
    Object.keys(args).forEach(function (key) {
      return queryParts.push(encodeURIComponent(key) + "=" + encodeURIComponent(args[key]));
    });
    return queryParts.join('&');
  },
  mergeQueryStr: function mergeQueryStr(first) {
    var _this = this;

    var args = typeof first === 'string' ? this.decodeUriArgs(first) : first;

    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    rest.forEach(function (arg) {
      var next = typeof arg === 'string' ? _this.decodeUriArgs(arg) : arg;
      Object.keys(next).forEach(function (prop) {
        args[prop] = next[prop];
      });
    });
    return this.encodeUriArgs(args);
  },
  augmentUri: function augmentUri(uri, args) {
    var m = /^([^?]+)\?(.+)+$/.exec(uri);

    if (m) {
      return m[1] + "?" + this.mergeQueryStr(m[2], args);
    }

    return uri + "?" + this.encodeUriArgs(args);
  },
  getURLParameter: function getURLParameter(name) {
    var value = new RegExp("[?|&]" + name + "=([^&;]+?)(&|#|;|$)").exec(window.location.search) || [undefined, ''];
    return decodeURIComponent(value[1].replace(/\+/g, '%20')) || null;
  }
};
var GoogleAnalytics = /*#__PURE__*/function () {
  function GoogleAnalytics(analytics, id, param) {
    var _this2 = this;

    if (param === void 0) {
      param = 'q';
    }

    this.unregisterFunctions = [];

    this.detatch = function () {
      return _this2.unregisterFunctions.forEach(function (fn) {
        return fn();
      });
    };

    this.onBodyReset = function (body) {
      return _this2.sendGAPageView(body);
    };

    this.onResultClicked = function (body) {
      return _this2.sendGAPageView(body);
    };

    this.onPageClose = function (body) {
      return _this2.sendGAPageView(body);
    };

    this.unregisterFunctions.push(analytics.listen(EVENT_ANALYTICS_PAGE_CLOSED, this.onPageClose));
    this.unregisterFunctions.push(analytics.listen(EVENT_ANALYTICS_BODY_RESET, this.onBodyReset));
    this.unregisterFunctions.push(analytics.listen(EVENT_ANALYTICS_RESULT_CLICKED, this.onResultClicked));

    if (!reactSdkUtils.isSSR()) {
      if (id !== undefined) {
        this.id = id;
      } else if (reactSdkUtils.isFunction(window[GoogleAnalyticsObjects.AnalyticsJS])) {
        this.id = GoogleAnalyticsObjects.AnalyticsJS;
      } else if (reactSdkUtils.isFunction(window[GoogleAnalyticsObjects.UniversalAnalytics])) {
        this.id = GoogleAnalyticsObjects.UniversalAnalytics;
      } else if (reactSdkUtils.isFunction(window[GoogleAnalyticsObjects.GTag])) {
        this.id = GoogleAnalyticsObjects.GTag;
      } else {
        this.id = null;
      }
    } else {
      this.id = null;
    }

    this.param = param;
  }

  var _proto = GoogleAnalytics.prototype;

  _proto.sendGAPageView = function sendGAPageView(body) {
    if (this.id && !reactSdkUtils.isSSR() && reactSdkUtils.isFunction(window[this.id])) {
      var _url$augmentUri;

      var pageAddress = url.augmentUri(window.location.href.substring(window.location.origin.length), (_url$augmentUri = {}, _url$augmentUri[this.param] = body, _url$augmentUri));

      if (this.id === GoogleAnalyticsObjects.GTag) {
        window[this.id]('event', 'page_view', {
          page_location: pageAddress
        });
      } else {
        window[this.id]('send', 'pageview', pageAddress);
      }
    }
  };

  return GoogleAnalytics;
}();

var escapeValue = function escapeValue(input) {
  if (input === void 0) {
    input = '';
  }

  var escaped = input;
  var chars = [','];
  chars.forEach(function (c) {
    escaped = reactSdkUtils.replaceAll(input, c, "\\" + c);
  });
  return escaped;
};

var events$1 = [EVENT_SELECTION_UPDATED, EVENT_OPTIONS_UPDATED];

var FilterBuilder = /*#__PURE__*/function () {
  function FilterBuilder(_ref) {
    var _this$listeners;

    var _ref$initial = _ref.initial,
        initial = _ref$initial === void 0 ? [] : _ref$initial,
        _ref$joinOperator = _ref.joinOperator,
        joinOperator = _ref$joinOperator === void 0 ? 'OR' : _ref$joinOperator,
        _ref$multi = _ref.multi,
        multi = _ref$multi === void 0 ? true : _ref$multi,
        _ref$options = _ref.options,
        options = _ref$options === void 0 ? {} : _ref$options,
        _ref$array = _ref.array,
        array = _ref$array === void 0 ? false : _ref$array,
        name = _ref.name,
        field = _ref.field,
        group = _ref.group,
        _ref$count = _ref.count,
        count = _ref$count === void 0 ? reactSdkUtils.isEmpty(options) : _ref$count;

    if (reactSdkUtils.isString(initial)) {
      initial = [initial];
    }

    this.current = initial;
    this.initial = initial;
    this.name = name;
    this.group = group;
    this.field = field;
    this.count = count;
    this.options = options;
    this.multi = multi;
    this.array = array;
    this.joinOperator = joinOperator;
    this.listeners = (_this$listeners = {}, _this$listeners[EVENT_SELECTION_UPDATED] = new Listener(), _this$listeners[EVENT_OPTIONS_UPDATED] = new Listener(), _this$listeners);
  }

  var _proto = FilterBuilder.prototype;

  _proto.listen = function listen(event, callback) {
    if (!events$1.includes(event)) {
      throw new Error("Unknown event type \"" + event + "\"");
    }

    return this.listeners[event].listen(callback);
  };

  _proto.set = function set(values, merge) {
    var _this = this;

    if (merge === void 0) {
      merge = false;
    }

    if (merge) {
      var nonDuplicate = values.filter(function (v) {
        return !_this.current.includes(v);
      });
      this.current = [].concat(this.current, nonDuplicate);
    } else {
      this.current = values;
    }

    this.emitSelectionUpdated();
  };

  _proto.remove = function remove(values) {
    this.current = this.current.filter(function (v) {
      return !values.includes(v);
    });
    this.emitSelectionUpdated();
  };

  _proto.isSet = function isSet(name) {
    return this.current.includes(name);
  };

  _proto.setOptions = function setOptions(options, merge) {
    if (merge === void 0) {
      merge = false;
    }

    if (merge) {
      this.options = _extends({}, this.options, options);
    } else {
      this.options = options;
    }

    this.emitOptionsUpdated();
  };

  _proto.getName = function getName() {
    return this.name;
  };

  _proto.getGroup = function getGroup() {
    return this.group;
  };

  _proto.getField = function getField() {
    return this.field;
  };

  _proto.getCount = function getCount() {
    return this.count;
  };

  _proto.getOptions = function getOptions() {
    return this.options;
  };

  _proto.get = function get() {
    return this.current;
  };

  _proto.isArray = function isArray() {
    return this.array;
  };

  _proto.isMulti = function isMulti() {
    return this.multi;
  };

  _proto.filter = function filter() {
    var _this2 = this;

    var options = this.current.map(function (c) {
      var f = _this2.options[c];

      if (reactSdkUtils.isFunction(f)) {
        f = f();
      }

      if (!reactSdkUtils.isEmpty(f)) {
        f = escapeValue(f);
      }

      if (_this2.count && f === undefined && c) {
        f = _this2.array ? _this2.field + " ~ [\"" + c + "\"]" : _this2.field + " = \"" + c + "\"";
      }

      return f;
    }).filter(Boolean);

    if (options.length < 2) {
      return options.join('');
    }

    return options.map(function (f) {
      return "(" + f + ")";
    }).join(" " + this.joinOperator + " ");
  };

  _proto.getBuckets = function getBuckets() {
    var _this3 = this;

    return Object.entries(this.options).map(function (_ref2) {
      var key = _ref2[0],
          value = _ref2[1];
      return _this3.name + "_" + key + ":" + value;
    }).join(',');
  };

  _proto.reset = function reset() {
    this.current = [].concat(this.initial);
    this.emitSelectionUpdated();
  };

  _proto.emitSelectionUpdated = function emitSelectionUpdated() {
    this.listeners[EVENT_SELECTION_UPDATED].notify(function (listener) {
      listener();
    });
  };

  _proto.emitOptionsUpdated = function emitOptionsUpdated() {
    this.listeners[EVENT_OPTIONS_UPDATED].notify(function (listener) {
      listener();
    });
  };

  return FilterBuilder;
}();

var events$2 = [EVENT_RANGE_UPDATED];

var RangeFilterBuilder = /*#__PURE__*/function () {
  function RangeFilterBuilder(_ref) {
    var _this$listeners;

    var field = _ref.field,
        name = _ref.name,
        group = _ref.group,
        _ref$aggregate = _ref.aggregate,
        aggregate = _ref$aggregate === void 0 ? true : _ref$aggregate,
        initial = _ref.initial,
        _ref$min = _ref.min,
        min = _ref$min === void 0 ? 0 : _ref$min,
        _ref$max = _ref.max,
        max = _ref$max === void 0 ? aggregate ? 0 : 100 : _ref$max,
        _ref$step = _ref.step,
        step = _ref$step === void 0 ? 1 : _ref$step,
        _ref$formatter = _ref.formatter,
        formatter = _ref$formatter === void 0 ? function (value) {
      return value.map(function (v) {
        return reactSdkUtils.roundToStep(v, step);
      });
    } : _ref$formatter;

    if (typeof initial === 'undefined') {
      this.initial = aggregate ? null : [min, max];
    } else {
      this.initial = initial;
    }

    this.range = this.initial;
    this.name = name;
    this.group = group;
    this.field = field;
    this.formatter = formatter;
    this.min = min;
    this.max = max;
    this.step = step;
    this.aggregate = aggregate;
    this.listeners = (_this$listeners = {}, _this$listeners[EVENT_RANGE_UPDATED] = new Listener(), _this$listeners);
  }

  var _proto = RangeFilterBuilder.prototype;

  _proto.listen = function listen(event, callback) {
    if (!events$2.includes(event)) {
      throw new Error("Unknown event type \"" + event + "\"");
    }

    return this.listeners[event].listen(callback);
  };

  _proto.get = function get() {
    return this.range;
  };

  _proto.set = function set(range, emitEvent) {
    if (emitEvent === void 0) {
      emitEvent = true;
    }

    this.range = range ? this.formatter(range) : range;

    if (emitEvent) {
      this.emitRangeUpdated();
    }
  };

  _proto.getName = function getName() {
    return this.name;
  };

  _proto.getGroup = function getGroup() {
    return this.group;
  };

  _proto.getField = function getField() {
    return this.field;
  };

  _proto.setMin = function setMin(value) {
    this.min = value;
  };

  _proto.setMax = function setMax(value) {
    this.max = value;
  };

  _proto.getMinMax = function getMinMax() {
    return [this.min, this.max];
  };

  _proto.getStep = function getStep() {
    return this.step;
  };

  _proto.filter = function filter() {
    if (!this.range) {
      return '';
    }

    return this.field + " >= " + this.range[0] + " AND " + this.field + " <= " + this.range[1];
  };

  _proto.isAggregate = function isAggregate() {
    return this.aggregate;
  };

  _proto.hasChanged = function hasChanged() {
    if (!this.range || !this.initial) {
      return this.range === this.initial;
    }

    return this.range[0] !== this.initial[0] || this.range[1] !== this.initial[1];
  };

  _proto.reset = function reset(emitEvent) {
    if (emitEvent === void 0) {
      emitEvent = true;
    }

    this.range = reactSdkUtils.isArray(this.initial) ? [].concat(this.initial) : this.initial;

    if (emitEvent) {
      this.emitRangeUpdated();
    }
  };

  _proto.format = function format(value) {
    return this.formatter(value);
  };

  _proto.emitRangeUpdated = function emitRangeUpdated() {
    var _this = this;

    this.listeners[EVENT_RANGE_UPDATED].notify(function (listener) {
      listener(_this);
    });
  };

  return RangeFilterBuilder;
}();

var buildArrayMatch = function buildArrayMatch(expressions) {
  var list = expressions.filter(Boolean);

  if (list.length > 1) {
    list = list.map(function (expression) {
      return "(" + expression + ")";
    });
  }

  return "ARRAY_MATCH(" + list.join(' AND ') + ")";
};

function groupFilters(filters, type, joinOperator) {
  var list = filters.map(function (f) {
    return {
      group: f.getGroup(),
      field: f.getField(),
      expression: f.filter(),
      count: f instanceof FilterBuilder && f.getCount()
    };
  });

  if (type === 'filter') {
    list = list.filter(function (_ref) {
      var expression = _ref.expression;
      return Boolean(expression);
    });
  }

  var groups = Object.entries(reactSdkUtils.groupBy(list, 'group')).filter(function (_ref2) {
    var group = _ref2[0];
    return Boolean(group);
  }).reduce(function (out, _ref3) {
    var _extends2;

    var key = _ref3[0],
        f = _ref3[1];
    return _extends({}, out, (_extends2 = {}, _extends2[key] = f.map(function (_ref4) {
      var expression = _ref4.expression;
      return expression;
    }), _extends2));
  }, {});

  if (type === 'filter') {
    var _Object$entries$reduc;

    var basicFilters = list.filter(function (_ref5) {
      var group = _ref5.group,
          count = _ref5.count;
      return !group && !count;
    }).map(function (_ref6) {
      var expression = _ref6.expression;
      return "(" + expression + ")";
    });
    return (_Object$entries$reduc = Object.entries(groups).reduce(function (out, _ref7) {
      var group = _ref7[0],
          expressions = _ref7[1];

      if (group !== 'undefined' && !reactSdkUtils.isEmpty(expressions)) {
        return [].concat(out, [buildArrayMatch(expressions)]);
      }

      return out;
    }, [])).concat.apply(_Object$entries$reduc, basicFilters).join(joinOperator);
  }

  return list.filter(function (_ref8) {
    var field = _ref8.field,
        count = _ref8.count;
    return !reactSdkUtils.isEmpty(field) && count;
  }).map(function (_ref9) {
    var group = _ref9.group,
        expression = _ref9.expression,
        count = _ref9.count;

    if (group && !reactSdkUtils.isEmpty(groups[group])) {
      return buildArrayMatch(groups[group]);
    }

    return count ? expression : null;
  }).filter(function (e) {
    return e !== null;
  }).join(joinOperator);
}

var events$3 = [EVENT_SELECTION_UPDATED, EVENT_OPTIONS_UPDATED, EVENT_RANGE_UPDATED];
function combineFilters(filters, joinOperator) {
  var _listeners;

  if (joinOperator === void 0) {
    joinOperator = 'AND';
  }

  var listeners = (_listeners = {}, _listeners[EVENT_SELECTION_UPDATED] = new Listener(), _listeners[EVENT_OPTIONS_UPDATED] = new Listener(), _listeners[EVENT_RANGE_UPDATED] = new Listener(), _listeners);
  var removeListenerFuncs = [];

  function listen(event, callback) {
    if (events$3.indexOf(event) === -1) {
      throw new Error("Unknown event type \"" + event + "\"");
    }

    return listeners[event].listen(callback);
  }

  filters.forEach(function (f) {
    if (f instanceof FilterBuilder) {
      removeListenerFuncs.push(f.listen(EVENT_SELECTION_UPDATED, function () {
        listeners[EVENT_SELECTION_UPDATED].notify(function (listener) {
          listener(f);
        });
      }), f.listen(EVENT_OPTIONS_UPDATED, function () {
        listeners[EVENT_OPTIONS_UPDATED].notify(function (listener) {
          listener(f);
        });
      }));
    }

    if (f instanceof RangeFilterBuilder) {
      removeListenerFuncs.push(f.listen(EVENT_RANGE_UPDATED, function () {
        listeners[EVENT_RANGE_UPDATED].notify(function (listener) {
          listener(f);
        });
      }));
    }
  });

  function removeChildFilterListeners() {
    removeListenerFuncs.forEach(function (fn) {
      return fn();
    });
  }

  var filter = function filter() {
    return groupFilters(filters, 'filter', " " + joinOperator + " ");
  };

  var buckets = function buckets() {
    return filters.filter(function (f) {
      return f instanceof FilterBuilder && !f.getCount();
    }).map(function (f) {
      return f instanceof FilterBuilder && f.getBuckets();
    }).filter(Boolean).join(',');
  };

  var countFilters = function countFilters() {
    return groupFilters(filters, 'countFilters', ',');
  };

  var count = function count() {
    return filters.filter(function (f) {
      return f instanceof FilterBuilder && f.getCount();
    }).map(function (f) {
      return f instanceof FilterBuilder && f.getField();
    }).filter(Boolean).join(',');
  };

  var min = function min() {
    return filters.filter(function (f) {
      return f instanceof RangeFilterBuilder && f.isAggregate();
    }).map(function (f) {
      return f.getField();
    }).join(',');
  };

  var max = function max() {
    return filters.filter(function (f) {
      return f instanceof RangeFilterBuilder && f.isAggregate();
    }).map(function (f) {
      return f.getField();
    }).join(',');
  };

  return {
    filter: filter,
    listen: listen,
    buckets: buckets,
    countFilters: countFilters,
    count: count,
    removeChildFilterListeners: removeChildFilterListeners,
    max: max,
    min: min
  };
}

var Response = /*#__PURE__*/function () {
  function Response(error, queryValues, response, values) {
    this.error = error;
    this.queryValues = queryValues;
    this.response = response;
    this.values = values;
  }

  var _proto = Response.prototype;

  _proto.isEmpty = function isEmpty() {
    return this.error === null && this.response === undefined && this.values === undefined && this.queryValues === undefined;
  };

  _proto.isError = function isError() {
    return this.error !== null;
  };

  _proto.getError = function getError() {
    return this.error;
  };

  _proto.getQueryValues = function getQueryValues() {
    return this.queryValues;
  };

  _proto.getResponse = function getResponse() {
    return this.response;
  };

  _proto.getValues = function getValues() {
    return this.values;
  };

  _proto.getResults = function getResults() {
    return this.response !== undefined ? this.response.get('results') : undefined;
  };

  _proto.getTotalResults = function getTotalResults() {
    return this.response !== undefined ? this.response.get('totalResults') : undefined;
  };

  _proto.getTime = function getTime() {
    return this.response !== undefined ? this.response.get('time') : undefined;
  };

  _proto.getAggregates = function getAggregates() {
    if (this.response === undefined) {
      return undefined;
    }

    var aggregates = this.response.get('aggregates');

    if (aggregates === undefined) {
      return undefined;
    }

    return aggregates;
  };

  _proto.getAggregateFilters = function getAggregateFilters() {
    if (this.response === undefined) {
      return undefined;
    }

    var aggregates = this.response.get('aggregateFilters');

    if (aggregates === undefined) {
      return undefined;
    }

    return aggregates;
  };

  return Response;
}();

var events$4 = [EVENT_TRACKING_RESET];
var Tracking = /*#__PURE__*/function () {
  function Tracking() {
    var _Object$entries;

    this.clientTracking = null;
    this.listeners = new Map(Object.entries((_Object$entries = {}, _Object$entries[EVENT_TRACKING_RESET] = new Listener(), _Object$entries)));
  }

  var _proto = Tracking.prototype;

  _proto.listen = function listen(event, callback) {
    if (events$4.indexOf(event) === -1) {
      throw new Error("Unknown event type \"" + event + "\"");
    }

    return this.listeners.get(event).listen(callback);
  };

  _proto.emitTrackingReset = function emitTrackingReset(values) {
    this.listeners.get(EVENT_TRACKING_RESET).notify(function (listener) {
      listener(values);
    });
  };

  _proto.reset = function reset(variables) {
    this.clientTracking.reset();

    if (variables !== undefined) {
      this.emitTrackingReset(variables);
    }
  };

  _proto.next = function next(variables) {
    if (this.clientTracking === null) {
      throw new Error('clientTracking is null');
    }

    return this.clientTracking.next(variables);
  };

  return Tracking;
}();

var getTrackingData = function getTrackingData() {
  var data = {};
  var ga = Cookies.get('_ga');

  if (ga) {
    data.ga = ga;
  }

  var sjID = Cookies.get('sjID');

  if (sjID) {
    data.sjID = sjID;
  }

  return data;
};

var ClickTracking = /*#__PURE__*/function (_Tracking) {
  _inheritsLoose(ClickTracking, _Tracking);

  function ClickTracking(field, qParam) {
    var _this;

    if (field === void 0) {
      field = 'url';
    }

    if (qParam === void 0) {
      qParam = 'q';
    }

    _this = _Tracking.call(this) || this;
    _this.field = field;
    _this.clientTracking = new sdkJs.InteractiveSession(qParam, new sdkJs.DefaultSession(sdkJs.TrackingType.Click, _this.field, getTrackingData()));
    return _this;
  }

  return ClickTracking;
}(Tracking);

var NoTracking = /*#__PURE__*/function (_Tracking) {
  _inheritsLoose(NoTracking, _Tracking);

  function NoTracking() {
    var _this;

    _this = _Tracking.call(this) || this;
    _this.field = '_id';
    _this.clientTracking = new sdkJs.DefaultSession(sdkJs.TrackingType.None, _this.field, getTrackingData());
    return _this;
  }

  return NoTracking;
}(Tracking);

var PosNegTracking = /*#__PURE__*/function (_Tracking) {
  _inheritsLoose(PosNegTracking, _Tracking);

  function PosNegTracking(field) {
    var _this;

    if (field === void 0) {
      field = 'url';
    }

    _this = _Tracking.call(this) || this;
    _this.field = field;
    _this.clientTracking = new sdkJs.DefaultSession(sdkJs.TrackingType.PosNeg, _this.field, getTrackingData());
    return _this;
  }

  return PosNegTracking;
}(Tracking);

var events$5 = [EVENT_SEARCH_SENT, EVENT_RESPONSE_UPDATED, EVENT_RESULT_CLICKED];
var Pipeline = /*#__PURE__*/function () {
  function Pipeline(config, name, tracking, analyticsAdapters) {
    var _this = this;

    if (tracking === void 0) {
      tracking = new NoTracking();
    }

    if (analyticsAdapters === void 0) {
      analyticsAdapters = [GoogleAnalytics];
    }

    this.response = new Response(null);
    var account = config.account,
        collection = config.collection,
        endpoint = config.endpoint,
        key = config.key,
        secret = config.secret;
    this.config = config;
    var p = {
      name: undefined,
      version: undefined
    };

    if (reactSdkUtils.isString(name)) {
      p.name = name;
    } else if ('name' in name) {
      p.name = name.name;
      p.version = name.version;
    }

    if (reactSdkUtils.isSSR()) {
      this.client = new sdkJs.Client(account, collection, endpoint, key, secret);
    } else {
      this.client = new sdkJs.Client(account, collection, endpoint);
    }

    this.pipeline = this.client.pipeline(p.name, p.version);
    this.tracking = tracking;
    this.listeners = new Map([[EVENT_SEARCH_SENT, new Listener()], [EVENT_RESPONSE_UPDATED, new Listener()], [EVENT_RESULT_CLICKED, new Listener()]]);
    this.searchCount = 0;
    this.response = new Response(null);
    this.analytics = new Analytics(this, this.tracking);
    analyticsAdapters.forEach(function (Adapter) {
      new Adapter(_this.analytics);
    });
  }

  var _proto = Pipeline.prototype;

  _proto.listen = function listen(event, callback) {
    if (events$5.indexOf(event) === -1) {
      throw new Error("Unknown event type \"" + event + "\"");
    }

    return this.listeners.get(event).listen(callback);
  };

  _proto._emitSearchSent = function _emitSearchSent(variables) {
    this.listeners.get(EVENT_SEARCH_SENT).notify(function (listener) {
      listener(variables);
    });
  };

  _proto._emitResponseUpdated = function _emitResponseUpdated(response) {
    this.listeners.get(EVENT_RESPONSE_UPDATED).notify(function (listener) {
      listener(response);
    });
  };

  _proto.emitResultClicked = function emitResultClicked(value) {
    this.listeners.get(EVENT_RESULT_CLICKED).notify(function (listener) {
      listener(value);
    });
  };

  _proto.search = function search(variables) {
    var _this2 = this;

    this.searchCount += 1;
    var currentSearch = this.searchCount;
    this.pipeline.search(variables, this.tracking.next(variables)).then(function (_ref) {
      var response = _ref[0],
          responseValues = _ref[1];

      if (currentSearch < _this2.searchCount) {
        return;
      }

      _this2.response = new Response(null, new Map(Object.entries(variables)), new Map(Object.entries(response)), new Map(Object.entries(responseValues)));
    })["catch"](function (error) {
      console.error(error);

      if (currentSearch < _this2.searchCount) {
        return;
      }

      _this2.response = new Response(error, new Map(Object.entries(variables)), undefined, undefined);
    })["finally"](function () {
      _this2._emitResponseUpdated(_this2.response);
    });

    this._emitSearchSent(variables);
  };

  _proto.clearResponse = function clearResponse(variables) {
    this.tracking.next(variables);
    this.searchCount += 1;
    this.response = new Response(null);

    this._emitResponseUpdated(this.response);
  };

  _proto.getResponse = function getResponse() {
    return this.response;
  };

  _proto.getAnalytics = function getAnalytics() {
    return this.analytics;
  };

  _proto.getClient = function getClient() {
    return this.client;
  };

  _proto.getTracking = function getTracking() {
    return this.tracking;
  };

  return Pipeline;
}();

var Variables = /*#__PURE__*/function () {
  function Variables(variables) {
    var _extends2;

    if (variables === void 0) {
      variables = {};
    }

    this.listeners = new Map([[EVENT_VALUES_UPDATED, new Listener()]]);
    this.variables = new Map(Object.entries(_extends((_extends2 = {}, _extends2[defaultConfig.qParam] = '', _extends2[defaultConfig.resultsPerPageParam] = 15, _extends2), variables)));
  }

  var _proto = Variables.prototype;

  _proto.listen = function listen(event, callback) {
    if (event !== EVENT_VALUES_UPDATED) {
      throw new Error("Unknown event type \"" + event + "\"");
    }

    return this.listeners.get(event).listen(callback);
  };

  _proto.set = function set(variables) {
    this._set(variables);

    this._emitUpdated(variables);
  };

  _proto.get = function get() {
    var variables = {};
    this.variables.forEach(function (variable, key) {
      if (typeof variable === 'function') {
        variables[key] = variable();
      } else if (Array.isArray(variable)) {
        variables[key] = variable.join(',');
      } else {
        variables[key] = String(variable);
      }
    });
    return variables;
  };

  _proto._emitUpdated = function _emitUpdated(changes) {
    var _this = this;

    this.listeners.get(EVENT_VALUES_UPDATED).notify(function (listener) {
      return listener(changes, function (variables) {
        return _this._set(variables);
      });
    });
  };

  _proto._set = function _set(variables) {
    var _this2 = this;

    Object.keys(variables).forEach(function (key) {
      if (variables[key] === undefined) {
        _this2.variables["delete"](key);
      } else {
        _this2.variables.set(key, variables[key]);
      }
    });
  };

  return Variables;
}();

var FieldDictionary = function FieldDictionary(input) {
  var _ref = input != null ? input : {},
      _ref$id = _ref.id,
      id = _ref$id === void 0 ? '_id' : _ref$id,
      _ref$url = _ref.url,
      url = _ref$url === void 0 ? 'url' : _ref$url,
      _ref$title = _ref.title,
      title = _ref$title === void 0 ? 'title' : _ref$title,
      _ref$subtitle = _ref.subtitle,
      subtitle = _ref$subtitle === void 0 ? 'url' : _ref$subtitle,
      _ref$description = _ref.description,
      description = _ref$description === void 0 ? 'description' : _ref$description,
      _ref$image = _ref.image,
      image = _ref$image === void 0 ? 'image' : _ref$image,
      _ref$price = _ref.price,
      price = _ref$price === void 0 ? 'price' : _ref$price,
      _ref$originalPrice = _ref.originalPrice,
      originalPrice = _ref$originalPrice === void 0 ? 'originalPrice' : _ref$originalPrice,
      _ref$rating = _ref.rating,
      rating = _ref$rating === void 0 ? 'rating' : _ref$rating;

  this.id = id;
  this.url = url;
  this.title = title;
  this.subtitle = subtitle;
  this.description = description;
  this.image = image;
  this.price = price;
  this.originalPrice = originalPrice;
  this.rating = rating;
};

var updateState = function updateState(query, responseValues, config) {
  var completion = query && responseValues ? responseValues.get(config.qParam) || '' : '';
  var suggestions = [];

  if (responseValues) {
    suggestions = (responseValues.get(config.qSuggestionsParam) || '').split(',').filter(function (s) {
      return s.length > 0;
    }).slice(0, config.maxSuggestions);
  }

  return {
    completion: completion,
    query: query,
    suggestions: suggestions
  };
};

var responseUpdatedListener = function responseUpdatedListener(variables, config, response) {
  var query = variables.get()[config.qParam] || '';
  var responseValues = response.getValues();
  return updateState(query, responseValues, config);
};

var valuesUpdatedListener = function valuesUpdatedListener(variables, pipeline, config) {
  var query = variables.get()[config.qParam] || '';
  var responseValues = pipeline.getResponse().getValues();
  return updateState(query, responseValues, config);
};

var _createContext = /*#__PURE__*/reactSdkUtils.createContext({
  strict: true,
  name: 'PipelineContext'
}),
    Provider = _createContext[0],
    useContext = _createContext[1];

var defaultState = {
  response: null,
  query: '',
  completion: '',
  suggestions: [],
  config: defaultConfig
};

var parseResponse = function parseResponse(initialResponse) {
  if (!reactSdkUtils.isString(initialResponse) || reactSdkUtils.isEmpty(initialResponse)) {
    return null;
  }

  var _JSON$parse = JSON.parse(initialResponse),
      _JSON$parse$queryValu = _JSON$parse.queryValues,
      queryValues = _JSON$parse$queryValu === void 0 ? {} : _JSON$parse$queryValu,
      _JSON$parse$response = _JSON$parse.response,
      response = _JSON$parse$response === void 0 ? {} : _JSON$parse$response,
      _JSON$parse$values = _JSON$parse.values,
      values = _JSON$parse$values === void 0 ? {} : _JSON$parse$values;

  return new Response(null, new Map(Object.entries(queryValues)), new Map(Object.entries(response)), new Map(Object.entries(values)));
};

var ContextProvider = function ContextProvider(_ref) {
  var _search$variables, _autocompleteProp$var;

  var children = _ref.children,
      search = _ref.search,
      autocompleteProp = _ref.autocomplete,
      defaultFilter = _ref.defaultFilter,
      searchOnLoad = _ref.searchOnLoad,
      initialResponseProp = _ref.initialResponse;
  var initialResponse = parseResponse(initialResponseProp);

  var _useState = React.useState(false),
      searching = _useState[0],
      setSearching = _useState[1];

  var _useState2 = React.useState(false),
      autocompleteSearching = _useState2[0],
      setAutocompleteSearching = _useState2[1];

  var _useState3 = React.useState(_extends({}, defaultState, {
    response: initialResponse
  })),
      searchState = _useState3[0],
      setSearchState = _useState3[1];

  var _useState4 = React.useState(defaultState),
      autocompleteState = _useState4[0],
      setAutocompleteState = _useState4[1];

  var _useState5 = React.useState(false),
      configDone = _useState5[0],
      setConfigDone = _useState5[1];

  var searchTimer = React.useRef();
  var searchAutocompleteTimer = React.useRef();
  var autocomplete = React.useRef(autocompleteProp);
  var variables = React.useRef((_search$variables = search.variables) != null ? _search$variables : new Variables());
  var autocompleteVariables = React.useRef((_autocompleteProp$var = autocompleteProp == null ? void 0 : autocompleteProp.variables) != null ? _autocompleteProp$var : new Variables());
  var response = search.pipeline.getResponse();

  if (response.isEmpty() && initialResponse !== null) {
    response = initialResponse;
  }

  if (!search.variables && !configDone) {
    Object.assign(search, {
      variables: variables.current
    });
  }

  if (autocompleteProp && !autocompleteProp.variables && !configDone) {
    Object.assign(autocompleteProp, {
      variables: autocompleteVariables.current
    });
  }

  if (!configDone) {
    var _search$filters, _variables$current$ge, _defaultFilter$toStri;

    var _filter = combineFilters((_search$filters = search.filters) != null ? _search$filters : []);

    var variablesFilterString = (_variables$current$ge = variables.current.get().filter) != null ? _variables$current$ge : '';
    var defaultFilterString = (_defaultFilter$toStri = defaultFilter == null ? void 0 : defaultFilter.toString()) != null ? _defaultFilter$toStri : '';
    variables.current.set({
      filter: function filter() {
        var expression = _filter.filter();

        return [defaultFilterString, variablesFilterString, reactSdkUtils.isEmpty(expression) ? '_id != ""' : expression].filter(Boolean).join(' AND ');
      },
      countFilters: function countFilters() {
        return _filter.countFilters();
      },
      buckets: function buckets() {
        return _filter.buckets();
      },
      count: function count() {
        return _filter.count();
      },
      min: function min() {
        return _filter.min();
      },
      max: function max() {
        return _filter.max();
      }
    });
  }

  var searchFn = React.useCallback(function (key) {
    return function (inputQuery, override) {
      var _text;

      if (override === void 0) {
        override = false;
      }

      var func = key === 'autocomplete' ? autocomplete.current : search;
      var state = key === 'autocomplete' ? autocompleteState : searchState;
      var setSearchingState = key === 'autocomplete' ? setAutocompleteSearching : setSearching;
      var timer = key === 'autocomplete' ? searchAutocompleteTimer : searchTimer;
      setSearchingState(true);
      setSearchState(function (state) {
        return _extends({}, state, {
          query: inputQuery != null ? inputQuery : state.query
        });
      });
      var pipeline = func.pipeline,
          variables = func.variables;
      var config = state.config;
      var text = (_text = {}, _text[config.qParam] = inputQuery != null ? inputQuery : variables.get()[config.qParam], _text[config.qOverrideParam] = undefined, _text[config.pageParam] = undefined, _text);

      if (override) {
        text[config.qOverrideParam] = 'true';
      }

      variables.set(text);

      if (timer.current) {
        clearTimeout(timer.current);
      }

      timer.current = setTimeout(function () {
        pipeline.search(variables.get());
      }, 50);
    };
  }, []);
  React.useEffect(function () {
    var mergedConfig = _extends({}, defaultConfig, search.config);

    setSearchState(function (state) {
      return _extends({}, state, {
        response: response,
        query: variables.current.get()[mergedConfig.qParam] || '',
        config: mergedConfig
      });
    });
    setAutocompleteState(function (state) {
      return _extends({}, state, {
        config: _extends({}, defaultConfig, search.config)
      });
    });
    var unregisterFunctions = [];

    if (search.filters) {
      var filter = combineFilters(search.filters);
      unregisterFunctions.push(filter.listen(EVENT_SELECTION_UPDATED, function () {
        return searchFn('search')();
      }), filter.listen(EVENT_RANGE_UPDATED, function () {
        return searchFn('search')();
      }), filter.removeChildFilterListeners);
    }

    var searchRenderTimer;
    unregisterFunctions.push(search.pipeline.listen(EVENT_RESPONSE_UPDATED, function (response) {
      var _response$getResults;

      clearTimeout(searchRenderTimer);
      searchRenderTimer = setTimeout(function () {
        setSearching(false);
        setSearchState(function (prevState) {
          return _extends({}, prevState, {
            response: response
          }, responseUpdatedListener(variables.current, prevState.config, response));
        });
      }, ((_response$getResults = response.getResults()) == null ? void 0 : _response$getResults.length) === 0 ? 500 : 20);
    }));
    unregisterFunctions.push(variables.current.listen(EVENT_VALUES_UPDATED, function () {
      return setSearchState(function (prevState) {
        return _extends({}, prevState, valuesUpdatedListener(variables.current, search.pipeline, prevState.config));
      });
    }));

    if (!autocomplete.current) {
      var _search$pipeline$conf = search.pipeline.config,
          account = _search$pipeline$conf.account,
          collection = _search$pipeline$conf.collection,
          endpoint = _search$pipeline$conf.endpoint;
      autocomplete.current = {
        pipeline: new Pipeline({
          account: account,
          collection: collection,
          endpoint: endpoint
        }, 'autocomplete'),
        variables: autocompleteVariables.current
      };
    }

    unregisterFunctions.push(autocomplete.current.pipeline.listen(EVENT_RESPONSE_UPDATED, function (response) {
      setAutocompleteSearching(false);
      setAutocompleteState(function (prevState) {
        return _extends({}, prevState, {
          response: response
        }, responseUpdatedListener(autocompleteVariables.current, prevState.config, response));
      });
    }));
    unregisterFunctions.push(autocompleteVariables.current.listen(EVENT_VALUES_UPDATED, function () {
      return setAutocompleteState(function (prevState) {
        return _extends({}, prevState, valuesUpdatedListener(autocompleteVariables.current, autocomplete.current.pipeline, prevState.config));
      });
    }));

    if (searchOnLoad) {
      search.pipeline.search(variables.current.get());
    }

    setConfigDone(true);
    return function () {
      unregisterFunctions.forEach(function (fn) {
        return fn();
      });
    };
  }, []);
  var clear = React.useCallback(function (key) {
    return function (vals) {
      var func = key === 'autocomplete' ? autocomplete.current : search;
      var pipeline = func.pipeline,
          variables = func.variables;

      if (vals !== undefined) {
        variables.set(vals);
      }

      pipeline.clearResponse(variables.get());
    };
  }, []);
  var handlePaginate = React.useCallback(function (page) {
    var _variables$set;

    var pipeline = search.pipeline,
        variables = search.variables;
    var config = searchState.config;
    variables.set((_variables$set = {}, _variables$set[config.pageParam] = String(page), _variables$set));
    pipeline.search(variables.get());
  }, [search.pipeline, search.variables, searchState.config]);
  var handleResultClicked = React.useCallback(function (url) {
    return search.pipeline.emitResultClicked(url);
  }, []);

  var getContext = function getContext(state) {
    var _autocomplete$current, _autocomplete$current2;

    return _extends({}, state, {
      search: _extends({}, state.search, {
        variables: variables.current,
        filters: search.filters,
        pipeline: search.pipeline,
        search: searchFn('search'),
        clear: clear('search'),
        fields: search.fields,
        searching: searching
      }),
      autocomplete: _extends({}, state.autocomplete, {
        variables: autocompleteVariables.current,
        filters: search.filters,
        pipeline: (_autocomplete$current = autocomplete.current) == null ? void 0 : _autocomplete$current.pipeline,
        search: searchFn('autocomplete'),
        clear: clear('autocomplete'),
        fields: (_autocomplete$current2 = autocomplete.current) == null ? void 0 : _autocomplete$current2.fields,
        searching: autocompleteSearching
      }),
      resultClicked: handleResultClicked,
      paginate: handlePaginate
    });
  };

  return React__default.createElement(Provider, {
    value: getContext({
      autocomplete: autocompleteState,
      search: searchState
    })
  }, children);
};

function useAutocomplete() {
  var _useContext = useContext(),
      _useContext$autocompl = _useContext.autocomplete,
      suggestions = _useContext$autocompl.suggestions,
      search = _useContext$autocompl.search,
      completion = _useContext$autocompl.completion,
      searching = _useContext$autocompl.searching;

  return {
    suggestions: suggestions,
    search: search,
    completion: completion,
    searching: searching
  };
}

function mapToObject(map) {
  var obj = {};

  if (map) {
    map.forEach(function (v, k) {
      if (typeof v === 'string' || typeof v === 'number') {
        obj[k] = v;
      }
    });
  }

  return obj;
}

function getBucketCount(response, value) {
  var _aggregateFilters$buc, _aggregateFilters$buc2, _aggregates$buckets$c, _aggregates$buckets, _count$value;

  if (!response || (response == null ? void 0 : response.isEmpty())) {
    return null;
  }

  var count = 0;
  var aggregates = response.getAggregates();
  var aggregateFilters = response.getAggregateFilters();

  if (aggregateFilters && Object.keys((_aggregateFilters$buc = (_aggregateFilters$buc2 = aggregateFilters.buckets) == null ? void 0 : _aggregateFilters$buc2.count) != null ? _aggregateFilters$buc : {}).includes(value)) {
    count = aggregateFilters.buckets.count;
  } else if (aggregates && Object.keys((_aggregates$buckets$c = (_aggregates$buckets = aggregates.buckets) == null ? void 0 : _aggregates$buckets.count) != null ? _aggregates$buckets$c : {}).includes(value)) {
    count = aggregates.buckets.count;
  }

  if (reactSdkUtils.isNumber(count)) {
    return 0;
  }

  return (_count$value = count[value]) != null ? _count$value : 0;
}

var priceRangePattern = /\d+\s-\s\d+/gm;
var patternTest = /*#__PURE__*/priceRangePattern.test.bind(priceRangePattern);
var collator = /*#__PURE__*/new Intl.Collator(! /*#__PURE__*/reactSdkUtils.isSSR() ? window.navigator.language : 'en-US', {
  numeric: true
});
var sortItems = function sortItems(list, sort, asc) {
  if (sort === void 0) {
    sort = 'alpha';
  }

  if (asc === void 0) {
    asc = true;
  }

  if (sort === 'none') {
    return list;
  }

  var byLabel = sort !== 'count';
  return [].concat(list).sort(function (_ref, _ref2) {
    var labelLeft = _ref[0],
        valueLeft = _ref[1];
    var labelRight = _ref2[0],
        valueRight = _ref2[1];
    var left = String(byLabel ? labelLeft : valueLeft);
    var right = String(byLabel ? labelRight : valueRight);

    switch (true) {
      case [left, right].every(patternTest):
        {
          var minLeft = left.split(' - ').map(Number)[0];
          var minRight = right.split(' - ').map(Number)[0];

          if (asc) {
            return collator.compare(String(minLeft), String(minRight));
          }

          return collator.compare(String(minRight), String(minLeft));
        }

      case left.startsWith('>'):
      case right.startsWith('<'):
        return asc ? 1 : -1;

      case left.startsWith('<'):
      case right.startsWith('>'):
        return asc ? -1 : 1;
    }

    if (asc) {
      return collator.compare(String(left), String(right));
    }

    return collator.compare(String(right), String(left));
  });
};

function useFilter(name, params) {
  if (params === void 0) {
    params = {};
  }

  var _useContext = useContext(),
      _useContext$search = _useContext.search,
      _useContext$search$fi = _useContext$search.filters,
      filters = _useContext$search$fi === void 0 ? [] : _useContext$search$fi,
      response = _useContext$search.response;

  var filter = React.useMemo(function () {
    return filters.filter(function (f) {
      return f instanceof FilterBuilder && f.getName() === name;
    })[0];
  }, []);

  if (!filter) {
    throw new Error("Filter \"" + name + "\" doesn't exist.");
  }

  var _useState = React.useState(filter.get()),
      selected = _useState[0],
      setInternalSelected = _useState[1];

  React.useEffect(function () {
    var removeListener = filter.listen(EVENT_SELECTION_UPDATED, function () {
      setInternalSelected(filter.get());
    });
    return function () {
      removeListener();
    };
  }, []);

  var setSelected = function setSelected(value, merge) {
    if (merge === void 0) {
      merge = false;
    }

    filter.set(value, merge);
  };

  var reset = function reset() {
    filter.reset();
  };

  var _params = params,
      _params$sort = _params.sort,
      sort = _params$sort === void 0 ? 'alpha' : _params$sort,
      _params$sortAscending = _params.sortAscending,
      sortAscending = _params$sortAscending === void 0 ? sort !== 'count' : _params$sortAscending;
  var options = React.useMemo(function () {
    if (!response || (response == null ? void 0 : response.isEmpty())) {
      return [];
    }

    var aggregates = response.getAggregates();
    var aggregateFilters = response.getAggregateFilters();
    var isCount = filter.getCount();
    var field = filter.getField();

    if (isCount && field) {
      var array = filter.isArray();
      var count = {};

      var _ref = (aggregateFilters || {})[field] || {};

      count = _ref.count;

      if (!count) {
        var _ref2 = (aggregates || {})[field] || {};

        var _ref2$count = _ref2.count;
        count = _ref2$count === void 0 ? {} : _ref2$count;
      }

      var temp = sortItems(Object.entries(count), sort, sortAscending).map(function (_ref3) {
        var label = _ref3[0],
            count = _ref3[1];
        return {
          label: label,
          count: count,
          value: array ? field + " ~ [\"" + label + "\"]" : field + " = \"" + label + "\""
        };
      });
      filter.setOptions(temp.reduce(function (a, c) {
        var _extends2;

        return _extends({}, a, (_extends2 = {}, _extends2[c.label] = c.value, _extends2));
      }, {}));
      return temp;
    }

    return sortItems(Object.entries(filter.getOptions()), sort, sortAscending).map(function (_ref4) {
      var label = _ref4[0],
          value = _ref4[1];
      var id = name + "_" + label;
      var count = getBucketCount(response, id);
      return {
        label: label,
        value: value,
        count: count
      };
    });
  }, [JSON.stringify(response == null ? void 0 : response.getResults())]);
  return {
    options: options,
    setSelected: setSelected,
    selected: selected,
    reset: reset,
    multi: filter.isMulti()
  };
}

function usePagination(key) {
  if (key === void 0) {
    key = 'search';
  }

  var context = useContext();
  var paginate = context.paginate;
  var _context$key = context[key],
      response = _context$key.response,
      config = _context$key.config;
  var queryValues = response == null ? void 0 : response.getQueryValues();
  var page = (queryValues == null ? void 0 : queryValues.get(config.pageParam)) ? parseInt(queryValues.get(config.pageParam), 10) : 1;
  var resultsPerPage = (queryValues == null ? void 0 : queryValues.get(config.resultsPerPageParam)) ? parseInt(queryValues == null ? void 0 : queryValues.get(config.resultsPerPageParam), 10) : 15;
  var totalResults = (response == null ? void 0 : response.getTotalResults()) || 0;
  var totalPages = Math.ceil(totalResults / resultsPerPage);
  var hasNext = React.useMemo(function () {
    return page < totalPages;
  }, [page, totalPages]);
  var hasPrevious = React.useMemo(function () {
    return page > 1;
  }, [page]);
  var nextPage = React.useCallback(function () {
    return hasNext && paginate(page + 1);
  }, [paginate, hasNext]);
  var previousPage = React.useCallback(function () {
    return hasPrevious && paginate(page - 1);
  }, [paginate, hasPrevious]);
  return {
    page: page,
    pageCount: totalPages,
    totalResults: totalResults,
    setPage: paginate,
    resultsPerPage: resultsPerPage,
    hasNext: hasNext,
    hasPrevious: hasPrevious,
    nextPage: nextPage,
    previousPage: previousPage
  };
}

function useQuery() {
  var _useContext = useContext(),
      _useContext$search = _useContext.search,
      search = _useContext$search.search,
      variables = _useContext$search.variables,
      query = _useContext$search.query;

  var setQuery = React.useCallback(function (q) {
    variables.set({
      q: q
    });
    search(q);
  }, [search, variables]);
  return {
    query: query,
    setQuery: setQuery
  };
}

function useRangeFilter(name) {
  var _useContext = useContext(),
      _useContext$search = _useContext.search,
      _useContext$search$fi = _useContext$search.filters,
      filters = _useContext$search$fi === void 0 ? [] : _useContext$search$fi,
      response = _useContext$search.response,
      query = _useContext$search.query;

  var prevQuery = React.useRef(null);
  var selectionUpdated = React.useRef(false);
  var filter = React.useMemo(function () {
    return filters.filter(function (f) {
      return f instanceof RangeFilterBuilder && f.getName() === name;
    })[0];
  }, []);
  var isAggregate = filter.isAggregate();
  var limit = filter.getMinMax();

  if (!filter) {
    throw new Error("Filter \"" + name + "\" doesn't exist.");
  }

  var _useState = React.useState(filter.get()),
      range = _useState[0],
      setInternalRange = _useState[1];

  var _useState2 = React.useState(limit[0]),
      min = _useState2[0],
      setMin = _useState2[1];

  var _useState3 = React.useState(limit[1]),
      max = _useState3[0],
      setMax = _useState3[1];

  React.useEffect(function () {
    if (isAggregate && prevQuery.current !== null) {
      filter.reset(false);
    }
  }, [query]);
  React.useEffect(function () {
    var removeListener = filter.listen(EVENT_RANGE_UPDATED, function () {
      setInternalRange(filter.get());
    });
    return function () {
      removeListener();
    };
  }, []);
  var setRange = React.useCallback(function (value) {
    filter.set(value);
  }, []);
  var showReset = React.useMemo(function () {
    if (!range) {
      return false;
    }

    if (isAggregate) {
      return range[0] !== min || range[1] !== max;
    }

    return filter.hasChanged();
  }, [range, min, max]);

  var reset = function reset() {
    if (isAggregate) {
      filter.set([].concat(filter.getMinMax()));
    } else {
      filter.reset();
    }
  };

  React.useEffect(function () {
    if (!isAggregate || prevQuery.current === query) {
      prevQuery.current = query;
      return;
    }

    if (!response || (response == null ? void 0 : response.isEmpty())) {
      setMin(range ? range[0] : limit[0]);
      setMax(range ? range[1] : limit[1]);
      selectionUpdated.current = false;
      return;
    }

    var field = filter.getField();
    var aggregates = response.getAggregates();
    var aggregateFilters = response.getAggregateFilters();
    var newMin = 0;
    var newMax = 0;
    var aggregate = (aggregates || {})[field] || {};
    var aggregateFilter = (aggregateFilters || {})[field] || {};

    if (!reactSdkUtils.isNullOrUndefined(aggregateFilter.min)) {
      newMin = aggregateFilter.min;
    } else if (!reactSdkUtils.isNullOrUndefined(aggregate.min)) {
      newMin = aggregate.min;
    }

    if (!reactSdkUtils.isNullOrUndefined(aggregateFilter.max)) {
      newMax = aggregateFilter.max;
    } else if (!reactSdkUtils.isNullOrUndefined(aggregate.max)) {
      newMax = aggregate.max;
    }

    var _filter$format = filter.format([newMin, newMax]);

    newMin = _filter$format[0];
    newMax = _filter$format[1];
    setMin(newMin);
    setMax(newMax);
    filter.setMin(newMin);
    filter.setMax(newMax);
    filter.set([newMin, newMax], false);
    setInternalRange([newMin, newMax]);
    prevQuery.current = query;
  }, [JSON.stringify(response == null ? void 0 : response.getResults())]);
  return {
    min: min,
    max: max,
    step: filter.getStep(),
    setRange: setRange,
    range: range,
    reset: reset,
    showReset: showReset
  };
}

function useResultsPerPage() {
  var _useContext = useContext(),
      _useContext$search = _useContext.search,
      search = _useContext$search.search,
      resultsPerPageParam = _useContext$search.config.resultsPerPageParam,
      variables = _useContext$search.variables;

  var setResultsPerPage = React.useCallback(function (size) {
    var _variables$set;

    variables.set((_variables$set = {}, _variables$set[resultsPerPageParam] = size, _variables$set));
    search();
  }, [variables, search]);
  var resultsPerPage = parseInt(variables.get()[resultsPerPageParam], 10);
  return {
    resultsPerPage: reactSdkUtils.isNumber(resultsPerPage) ? resultsPerPage : 15,
    setResultsPerPage: setResultsPerPage
  };
}

function useCustomSearch(_ref) {
  var pipeline = _ref.pipeline,
      variables = _ref.variables;

  var _useState = React.useState(false),
      searching = _useState[0],
      setSearching = _useState[1];

  var searchFn = React.useCallback(function (q) {
    setSearching(true);

    if (q === '') {
      pipeline.clearResponse(variables.get());
    } else {
      if (q) {
        var _variables$set;

        variables.set((_variables$set = {}, _variables$set[defaultConfig.qParam] = q, _variables$set));
      }

      pipeline.search(variables.get());
    }
  }, [pipeline, variables]);

  var _useState2 = React.useState({
    search: searchFn,
    error: null
  }),
      searchOutput = _useState2[0],
      setSearchOutput = _useState2[1];

  React.useEffect(function () {
    searchFn();
    return pipeline.listen(EVENT_RESPONSE_UPDATED, function (response) {
      setSearching(false);
      setSearchOutput(function (o) {
        return _extends({}, o, {
          results: response == null ? void 0 : response.getResults(),
          latency: response == null ? void 0 : response.getTime(),
          totalResults: response == null ? void 0 : response.getTotalResults(),
          error: response == null ? void 0 : response.getError()
        });
      });
    });
  }, []);
  React.useEffect(function () {
    return variables.listen(EVENT_VALUES_UPDATED, function () {
      searchFn();
    });
  }, []);
  return _extends({}, searchOutput, {
    searching: searching
  });
}

function useNormalSearch(_ref2) {
  var queryOverride = _ref2.queryOverride,
      _ref2$allowEmptySearc = _ref2.allowEmptySearch,
      allowEmptySearch = _ref2$allowEmptySearc === void 0 ? true : _ref2$allowEmptySearc;

  var _useState3 = React.useState(null),
      error = _useState3[0],
      setError = _useState3[1];

  var _useContext = useContext(),
      _useContext$search = _useContext.search,
      searching = _useContext$search.searching,
      response = _useContext$search.response,
      search = _useContext$search.search,
      _useContext$autocompl = _useContext.autocomplete,
      searchInstantFn = _useContext$autocompl.search,
      suggestions = _useContext$autocompl.suggestions;

  var results = response == null ? void 0 : response.getResults();
  var searchInstant = React.useCallback(function (q) {
    return searchInstantFn(q);
  }, []);
  React.useEffect(function () {
    if (queryOverride !== undefined) {
      if (allowEmptySearch || queryOverride !== '') {
        search(queryOverride);
      }
    } else {
      search();
    }
  }, [queryOverride]);
  React.useEffect(function () {
    var _response$getError$er, _response$getError;

    if (response) {
      switch (true) {
        case response.isError():
          setError((_response$getError$er = (_response$getError = response.getError()) == null ? void 0 : _response$getError.error) != null ? _response$getError$er : new Error('Something went wrong. Please try again.'));
          break;

        case !response.isError():
          setError(null);
          break;
      }
    }
  }, [response]);
  return {
    latency: response == null ? void 0 : response.getTime(),
    totalResults: response == null ? void 0 : response.getTotalResults(),
    suggestions: suggestions != null ? suggestions : [],
    results: results,
    search: search,
    searchInstant: searchInstant,
    searching: searching,
    error: error
  };
}

function useSearch(params) {
  if (typeof params === 'object' && 'pipeline' in params && 'variables' in params) {
    return useCustomSearch(params);
  }

  return useNormalSearch(params != null ? params : {});
}

function useSearchContext() {
  var _response$isEmpty;

  var _useContext = useContext(),
      _useContext$search = _useContext.search,
      config = _useContext$search.config,
      response = _useContext$search.response,
      search = _useContext$search.search,
      searching = _useContext$search.searching,
      _useContext$search$fi = _useContext$search.fields,
      fields = _useContext$search$fi === void 0 ? {} : _useContext$search$fi,
      clear = _useContext$search.clear;

  var _usePagination = usePagination('search'),
      page = _usePagination.page,
      resultsPerPage = _usePagination.resultsPerPage,
      totalResults = _usePagination.totalResults,
      pageCount = _usePagination.pageCount,
      setPage = _usePagination.setPage;

  var mapResponse = mapToObject(response == null ? void 0 : response.getResponse());
  var results = response == null ? void 0 : response.getResults();
  return {
    empty: (_response$isEmpty = response == null ? void 0 : response.isEmpty()) != null ? _response$isEmpty : false,
    error: response == null ? void 0 : response.getError(),
    queryValues: response == null ? void 0 : response.getQueryValues(),
    latency: response == null ? void 0 : response.getTime(),
    page: page,
    resultsPerPage: resultsPerPage,
    totalResults: totalResults,
    pageCount: pageCount,
    setPage: setPage,
    search: search,
    results: results,
    response: mapResponse,
    searching: searching,
    searched: !reactSdkUtils.isNullOrUndefined(results),
    fields: fields,
    config: config,
    clear: clear
  };
}

function useSorting() {
  var _variables$get$sort;

  var _useContext = useContext(),
      _useContext$search = _useContext.search,
      search = _useContext$search.search,
      variables = _useContext$search.variables;

  var setSorting = React.useCallback(function (order) {
    variables.set({
      sort: order
    });
    search();
  }, [variables, search]);
  return {
    sorting: (_variables$get$sort = variables.get().sort) != null ? _variables$get$sort : '',
    setSorting: setSorting
  };
}

function useTracking() {
  var _useContext = useContext(),
      resultClicked = _useContext.resultClicked,
      pipeline = _useContext.search.pipeline;

  var client = pipeline.getClient();
  return {
    consumeInteractionToken: client.interactionConsume,
    handleResultClicked: resultClicked
  };
}

function useVariables() {
  var _useContext = useContext(),
      variables = _useContext.search.variables;

  return {
    variables: variables
  };
}

exports.ClickTracking = ClickTracking;
exports.EVENT_ANALYTICS_BODY_RESET = EVENT_ANALYTICS_BODY_RESET;
exports.EVENT_ANALYTICS_PAGE_CLOSED = EVENT_ANALYTICS_PAGE_CLOSED;
exports.EVENT_ANALYTICS_RESULT_CLICKED = EVENT_ANALYTICS_RESULT_CLICKED;
exports.EVENT_OPTIONS_UPDATED = EVENT_OPTIONS_UPDATED;
exports.EVENT_RANGE_UPDATED = EVENT_RANGE_UPDATED;
exports.EVENT_RESPONSE_UPDATED = EVENT_RESPONSE_UPDATED;
exports.EVENT_RESULT_CLICKED = EVENT_RESULT_CLICKED;
exports.EVENT_SEARCH_SENT = EVENT_SEARCH_SENT;
exports.EVENT_SELECTION_UPDATED = EVENT_SELECTION_UPDATED;
exports.EVENT_TRACKING_RESET = EVENT_TRACKING_RESET;
exports.EVENT_VALUES_UPDATED = EVENT_VALUES_UPDATED;
exports.FieldDictionary = FieldDictionary;
exports.FilterBuilder = FilterBuilder;
exports.Pipeline = Pipeline;
exports.PosNegTracking = PosNegTracking;
exports.RangeFilterBuilder = RangeFilterBuilder;
exports.Response = Response;
exports.SearchProvider = ContextProvider;
exports.Variables = Variables;
exports.combineFilters = combineFilters;
exports.useAutocomplete = useAutocomplete;
exports.useFilter = useFilter;
exports.usePagination = usePagination;
exports.useQuery = useQuery;
exports.useRangeFilter = useRangeFilter;
exports.useResultsPerPage = useResultsPerPage;
exports.useSearch = useSearch;
exports.useSearchContext = useSearchContext;
exports.useSorting = useSorting;
exports.useTracking = useTracking;
exports.useVariables = useVariables;
//# sourceMappingURL=react-hooks.cjs.development.js.map
