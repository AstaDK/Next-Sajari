{"version":3,"file":"react-hooks.cjs.production.min.js","sources":["../src/ContextProvider/Config.ts","../src/ContextProvider/controllers/analytics/GoogleAnalytics.ts","../src/ContextProvider/controllers/Listener.ts","../src/ContextProvider/controllers/analytics/Analytics.ts","../src/ContextProvider/events.ts","../src/ContextProvider/controllers/filters/FilterBuilder.ts","../src/ContextProvider/controllers/filters/RangeFilterBuilder.ts","../src/ContextProvider/controllers/filters/utils.ts","../src/ContextProvider/controllers/filters/combineFilters.ts","../src/ContextProvider/controllers/Response.ts","../src/ContextProvider/controllers/tracking/Tracking.ts","../src/ContextProvider/controllers/tracking/utils.ts","../src/ContextProvider/controllers/tracking/ClickTracking.ts","../src/ContextProvider/controllers/tracking/NoTracking.ts","../src/ContextProvider/controllers/tracking/PosNegTracking.ts","../src/ContextProvider/controllers/Pipeline.ts","../src/ContextProvider/controllers/Variables.ts","../src/ContextProvider/index.tsx","../src/useFilter/utils.ts","../src/usePagination/index.ts","../src/ContextProvider/types.ts","../src/useAutocomplete/index.ts","../src/useFilter/index.ts","../src/utils/response.ts","../src/useQuery/index.ts","../src/useRangeFilter/index.ts","../src/useResultsPerPage/index.ts","../src/useSearch/index.ts","../src/useSearchContext/index.ts","../src/utils/mapToObject.ts","../src/useSorting/index.ts","../src/useTracking/index.ts","../src/useVariables/index.ts"],"sourcesContent":["export interface Config {\n  qParam: string;\n  qOverrideParam: string;\n  qSuggestionsParam: string;\n  resultsPerPageParam: string;\n  pageParam: string;\n  maxSuggestions: number;\n}\n\nexport const defaultConfig: Config = {\n  qParam: 'q',\n  qOverrideParam: 'q.override',\n  qSuggestionsParam: 'q.suggestions',\n  resultsPerPageParam: 'resultsPerPage',\n  pageParam: 'page',\n  maxSuggestions: 10,\n};\n","/* eslint-disable no-restricted-syntax */\nimport { isFunction, isSSR } from '@sajari/react-sdk-utils';\n\nimport { EVENT_ANALYTICS_BODY_RESET, EVENT_ANALYTICS_PAGE_CLOSED, EVENT_ANALYTICS_RESULT_CLICKED } from '../../events';\nimport { UnlistenFn } from '../Listener';\nimport { Analytics } from './Analytics';\n\nenum GoogleAnalyticsObjects {\n  UniversalAnalytics = '_ua',\n  AnalyticsJS = 'ga',\n  GTag = 'gtag',\n}\n\nconst url = {\n  /**\n   * Convert a query string in to an object\n   */\n  decodeUriArgs(queryStr: string) {\n    const args = {} as { [k: string]: string };\n    const a = queryStr.split('&');\n    for (const i in a) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (a.hasOwnProperty(i)) {\n        const b = a[i].split('=');\n        args[decodeURIComponent(b[0])] = decodeURIComponent(b[1]);\n      }\n    }\n    return args;\n  },\n\n  /**\n   * Convert an arguments object in to a query string\n   */\n  encodeUriArgs(args: { [k: string]: string }) {\n    const queryParts: string[] = [];\n    Object.keys(args).forEach((key) => queryParts.push(`${encodeURIComponent(key)}=${encodeURIComponent(args[key])}`));\n    return queryParts.join('&');\n  },\n\n  /**\n   * Merges query strings or objects into a single query string. Accepts a variable number of query string/objects\n   * to merge. The latter overrides the former.\n   */\n  mergeQueryStr(first: string | { [k: string]: string }, ...rest: Array<string | { [k: string]: string }>) {\n    const args = typeof first === 'string' ? this.decodeUriArgs(first) : first;\n    rest.forEach((arg) => {\n      const next = typeof arg === 'string' ? this.decodeUriArgs(arg) : arg;\n      Object.keys(next).forEach((prop) => {\n        args[prop] = next[prop];\n      });\n    });\n    return this.encodeUriArgs(args);\n  },\n\n  /**\n   * Takes an existing URL and merges additional data into the query string\n   */\n  augmentUri(uri: string, args: { [k: string]: string }) {\n    const m = /^([^?]+)\\?(.+)+$/.exec(uri);\n    if (m) {\n      return `${m[1]}?${this.mergeQueryStr(m[2], args)}`;\n    }\n    return `${uri}?${this.encodeUriArgs(args)}`;\n  },\n\n  /**\n   * Get a parameter from the URL\n   */\n  getURLParameter(name: string) {\n    const value = new RegExp(`[?|&]${name}=([^&;]+?)(&|#|;|$)`).exec(window.location.search) || [undefined, ''];\n\n    return decodeURIComponent((value[1] as string).replace(/\\+/g, '%20')) || null;\n  },\n};\n\nexport class GoogleAnalytics {\n  private id: string | null;\n\n  private param: string;\n\n  private unregisterFunctions: UnlistenFn[] = [];\n\n  /**\n   * Constructs a GoogleAnalytics object.\n   * @param {Analytics} analytics The analytics object to attach to.\n   * @param {string} [id=undefined] The name of the ga global object. Defaults to \"ga\" or \"_ua\" if one isn't supplied.\n   * @param {string} [param=\"q\"] The URL parameter to use to indicate a search. Default to \"q\".\n   */\n  constructor(analytics: Analytics, id?: string, param = 'q') {\n    this.unregisterFunctions.push(analytics.listen(EVENT_ANALYTICS_PAGE_CLOSED, this.onPageClose));\n    this.unregisterFunctions.push(analytics.listen(EVENT_ANALYTICS_BODY_RESET, this.onBodyReset));\n    this.unregisterFunctions.push(analytics.listen(EVENT_ANALYTICS_RESULT_CLICKED, this.onResultClicked));\n\n    if (!isSSR()) {\n      if (id !== undefined) {\n        this.id = id;\n      } else if (isFunction(window[GoogleAnalyticsObjects.AnalyticsJS])) {\n        this.id = GoogleAnalyticsObjects.AnalyticsJS;\n      } else if (isFunction(window[GoogleAnalyticsObjects.UniversalAnalytics])) {\n        this.id = GoogleAnalyticsObjects.UniversalAnalytics;\n      } else if (isFunction(window[GoogleAnalyticsObjects.GTag])) {\n        this.id = GoogleAnalyticsObjects.GTag;\n      } else {\n        this.id = null;\n      }\n    } else {\n      this.id = null;\n    }\n    this.param = param;\n  }\n\n  /**\n   * Stops this object listening for events.\n   */\n  public detatch = () => this.unregisterFunctions.forEach((fn) => fn());\n\n  /**\n   * Sends a page view event if ga is found on the page and we're not in dev mode.\n   */\n  public sendGAPageView(body: string) {\n    if (this.id && !isSSR() && isFunction(window[this.id])) {\n      // Merge the body in with the existing query params in the url\n      const pageAddress = url.augmentUri(\n        // Take only the portion of the url following the domain\n        window.location.href.substring(window.location.origin.length),\n        { [this.param]: body },\n      );\n\n      if (this.id === GoogleAnalyticsObjects.GTag) {\n        window[this.id]('event', 'page_view', {\n          page_location: pageAddress,\n        });\n      } else {\n        window[this.id]('send', 'pageview', pageAddress);\n      }\n    }\n  }\n\n  /**\n   * Callback for when the body has been reset. Calls sendGAPageView.\n   */\n  public onBodyReset = (body: string) => this.sendGAPageView(body);\n\n  /**\n   * Callback for when a result has been clicked. Calls sendGAPageView.\n   */\n  public onResultClicked = (body: string) => this.sendGAPageView(body);\n\n  /**\n   * Callback for when the page has been closed. Calls sendGAPageView.\n   */\n  public onPageClose = (body: string) => this.sendGAPageView(body);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any, no-console */\nexport type CallbackFn = (...args: any[]) => void;\nexport type UnlistenFn = () => void;\n\nexport class Listener {\n  private listeners: CallbackFn[];\n\n  /**\n   * Constructs a listener object.\n   */\n  constructor() {\n    this.listeners = [];\n  }\n\n  /**\n   * Adds a callback to the listener.\n   * Returns a function that will unregister the callback from the listener when called.\n   * @param callback The callback to be registered.\n   * @return The unregister function to remove the callback from the listener.\n   */\n  public listen(callback: CallbackFn): UnlistenFn {\n    this.listeners.push(callback);\n    return () => this.unlisten(callback);\n  }\n\n  /**\n   * Removes a callback from the listener.\n   */\n  public unlisten(callback: CallbackFn): void {\n    const index = this.listeners.indexOf(callback);\n    if (index >= 0) {\n      this.listeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Notify takes a function and calls it for every listener.\n   * The listener is supplied as the first argument to the function.\n   * @param {function(callback: Function)} fn Function to call each of the callbacks in the listener with.\n   */\n  public notify(fn: (callback: CallbackFn) => void): void {\n    this.listeners.forEach((l) => {\n      try {\n        fn(l);\n      } catch (e) {\n        if (console && console.error) {\n          console.error(e);\n        }\n      }\n    });\n  }\n}\n\nexport type ListenerMap = Map<string, Listener>;\n","import { isSSR } from '@sajari/react-sdk-utils';\n\nimport {\n  EVENT_ANALYTICS_BODY_RESET,\n  EVENT_ANALYTICS_PAGE_CLOSED,\n  EVENT_ANALYTICS_RESULT_CLICKED,\n  EVENT_RESPONSE_UPDATED,\n  EVENT_RESULT_CLICKED,\n  EVENT_TRACKING_RESET,\n} from '../../events';\nimport { CallbackFn, Listener, ListenerMap } from '../Listener';\nimport { Pipeline } from '../Pipeline';\nimport { Response } from '../Response';\nimport { Tracking } from '../tracking';\n\nconst events = [EVENT_ANALYTICS_PAGE_CLOSED, EVENT_ANALYTICS_BODY_RESET, EVENT_ANALYTICS_RESULT_CLICKED];\n\n/**\n * Analytics is an adaptor which listens for events on Pipeline and\n * Tracking and re-emits them as analytics-based events.\n */\nexport class Analytics {\n  private enabled: boolean;\n\n  private body: string;\n\n  private pipeline: Pipeline;\n\n  private tracking: Tracking;\n\n  private listeners: ListenerMap;\n\n  private longestNonAutocompletedBody: string;\n\n  private longestAutocompletedBody: string;\n\n  private bodyLabel: string;\n\n  private bodyAutocompletedLabel: string;\n\n  /**\n   * Constructs an analytics object that operates on the specified pipeline.\n   */\n  constructor(pipeline: Pipeline, tracking: Tracking) {\n    this.enabled = false;\n    this.body = '';\n\n    this.pipeline = pipeline;\n    this.tracking = tracking;\n\n    this.listeners = new Map(\n      Object.entries({\n        [EVENT_ANALYTICS_PAGE_CLOSED]: new Listener(),\n        [EVENT_ANALYTICS_BODY_RESET]: new Listener(),\n        [EVENT_ANALYTICS_RESULT_CLICKED]: new Listener(),\n      }),\n    );\n\n    // longest values are for sending the users last intended query on reset\n    this.longestNonAutocompletedBody = '';\n    this.longestAutocompletedBody = '';\n\n    // default to working with website pipeline values\n    this.bodyLabel = 'q';\n    this.bodyAutocompletedLabel = 'q';\n\n    if (!isSSR()) {\n      window.addEventListener('beforeunload', this.beforeunload);\n    }\n\n    this.pipeline.listen(EVENT_RESPONSE_UPDATED, this.responseUpdated);\n    this.pipeline.listen(EVENT_RESULT_CLICKED, this.resultClicked);\n    this.tracking.listen(EVENT_TRACKING_RESET, this.resetBody);\n  }\n\n  /**\n   * Register a listener for a specific event.\n   * @param event Event to listen for\n   * @param callback Callback to run when the event happens.\n   * @return The unregister function to remove the callback from the listener.\n   */\n  public listen(event: string, callback: CallbackFn) {\n    if (events.indexOf(event) === -1) {\n      throw new Error(`Unknown event type \"${event}\"`);\n    }\n    return (this.listeners.get(event) as Listener).listen(callback);\n  }\n\n  /**\n   * Runs before the page is closed/navigated away from. Can trigger a ga onPageClose call.\n   */\n  public beforeunload = () => {\n    if (this.enabled && this.body) {\n      (this.listeners.get(EVENT_ANALYTICS_PAGE_CLOSED) as Listener).notify((callback) => {\n        callback(this.body);\n      });\n      this.enabled = false; // TODO(tbillington): unload -> disable!!\n    }\n  };\n\n  /**\n   * Resets the currently held parameters. Can trigger a ga onBodyReset call.\n   */\n  public resetBody = () => {\n    if (this.enabled) {\n      (this.listeners.get(EVENT_ANALYTICS_BODY_RESET) as Listener).notify((callback) => {\n        callback(this.body);\n      });\n\n      this.longestNonAutocompletedBody = '';\n      this.longestAutocompletedBody = '';\n      this.enabled = false;\n    }\n  };\n\n  /**\n   * Runs when the response has been updated. Updates the currently held search parameters.\n   */\n  public responseUpdated = (response: Response) => {\n    if (response.isEmpty() || response.isError()) {\n      return;\n    }\n\n    this.enabled = true;\n\n    const originalBody = (response.getQueryValues() as Map<string, string>).get(this.bodyLabel) || '';\n    const responseBody = (response.getValues() as Map<string, string>).get(this.bodyAutocompletedLabel) || originalBody;\n\n    this.body = responseBody;\n\n    // Here we check the lengths of the non-autocompleted bodies.\n    // We do this because while the user is backspacing their query\n    // the new autocompleted body may be longer than their actual input,\n    // but we want to record their input rather than a completion resulting\n    // from them removing chars.\n    if (originalBody.length >= this.longestNonAutocompletedBody.length) {\n      this.longestNonAutocompletedBody = originalBody;\n      this.longestAutocompletedBody = responseBody;\n    }\n  };\n\n  /**\n   * Runs when a result has been clicked. Can trigger a ga onResultClicked call.\n   */\n  public resultClicked = () => {\n    if (this.enabled && this.body) {\n      (this.listeners.get(EVENT_ANALYTICS_RESULT_CLICKED) as Listener).notify((callback) => {\n        callback(this.body);\n      });\n      this.longestNonAutocompletedBody = '';\n      this.longestAutocompletedBody = '';\n      this.enabled = false;\n    }\n  };\n}\n","export const EVENT_SEARCH_SENT = 'search-sent';\nexport const EVENT_RESPONSE_UPDATED = 'response-updated';\nexport const EVENT_RESULT_CLICKED = 'result-clicked';\n\nexport const EVENT_VALUES_UPDATED = 'values-changed';\n\nexport const EVENT_TRACKING_RESET = 'tracking-reset';\n\nexport const EVENT_ANALYTICS_PAGE_CLOSED = 'page-close-analytics';\nexport const EVENT_ANALYTICS_BODY_RESET = 'body-reset-analytics';\nexport const EVENT_ANALYTICS_RESULT_CLICKED = 'result-clicked-analytics';\n\nexport const EVENT_SELECTION_UPDATED = 'selection-updated';\nexport const EVENT_OPTIONS_UPDATED = 'options-updated';\n\nexport const EVENT_RANGE_UPDATED = 'range-updated';\n","/* eslint-disable no-param-reassign */\nimport { isEmpty, isFunction, isString, replaceAll } from '@sajari/react-sdk-utils';\n\nimport { EVENT_OPTIONS_UPDATED, EVENT_SELECTION_UPDATED } from '../../events';\nimport { Listener } from '../Listener';\nimport { FilterOptions, JoinOperator, Options } from './types';\n\n// Escape any characters that will break the request\nconst escapeValue = (input = '') => {\n  let escaped = input;\n  const chars = [','];\n\n  chars.forEach((c) => {\n    escaped = replaceAll(input, c, `\\\\${c}`);\n  });\n\n  return escaped;\n};\n\nconst events = [EVENT_SELECTION_UPDATED, EVENT_OPTIONS_UPDATED];\n\n/**\n * Filter is a helper class for building filters from UI components.\n */\nexport default class FilterBuilder {\n  private current: string[];\n\n  private initial: string[];\n\n  private name: string;\n\n  private group: string | undefined;\n\n  private field: string | undefined;\n\n  private options: Options;\n\n  private multi: boolean;\n\n  private count: boolean;\n\n  private array: boolean;\n\n  private joinOperator: JoinOperator;\n\n  private listeners: { [k: string]: Listener };\n\n  /**\n   * Constructs an instance of Filter.\n   *\n   * @example\n   * const filter = new FilterBuilder({});\n   */\n  constructor({\n    initial = [],\n    joinOperator = 'OR',\n    multi = true,\n    options = {},\n    array = false,\n    name,\n    field,\n    group,\n    count = isEmpty(options),\n  }: FilterOptions) {\n    if (isString(initial)) {\n      initial = [initial];\n    }\n\n    /** @private */\n    this.current = initial;\n    /** @private */\n    this.initial = initial;\n    /** @private */\n    this.name = name;\n    /** @private */\n    this.group = group;\n    /** @private */\n    this.field = field;\n    /** @private */\n    this.count = count;\n    /** @private */\n    this.options = options;\n    /** @private */\n    this.multi = multi;\n    /** @private */\n    this.array = array;\n    /** @private */\n    this.joinOperator = joinOperator;\n    /** @private */\n    this.listeners = {\n      [EVENT_SELECTION_UPDATED]: new Listener(),\n      [EVENT_OPTIONS_UPDATED]: new Listener(),\n    };\n  }\n\n  /**\n   * Register a listener for a specific event.\n   */\n  public listen(event: string, callback: (filter: FilterBuilder) => void): () => void {\n    if (!events.includes(event)) {\n      throw new Error(`Unknown event type \"${event}\"`);\n    }\n    return this.listeners[event].listen(callback);\n  }\n\n  /**\n   * Set the state of the filter.\n   */\n  public set(values: string[], merge = false) {\n    if (merge) {\n      const nonDuplicate = values.filter((v) => !this.current.includes(v));\n      this.current = [...this.current, ...nonDuplicate];\n    } else {\n      this.current = values;\n    }\n\n    this.emitSelectionUpdated();\n  }\n\n  /**\n   * Remove a list of values from the current state\n   */\n  public remove(values: string[]) {\n    this.current = this.current.filter((v) => !values.includes(v));\n    this.emitSelectionUpdated();\n  }\n\n  /**\n   * returns whether the filter is set or not.\n   */\n  public isSet(name: string): boolean {\n    return this.current.includes(name);\n  }\n\n  /**\n   * Set or merge filter options.\n   */\n  public setOptions(options: Options, merge = false) {\n    if (merge) {\n      this.options = { ...this.options, ...options };\n    } else {\n      this.options = options;\n    }\n\n    this.emitOptionsUpdated();\n  }\n\n  public getName() {\n    return this.name;\n  }\n\n  public getGroup() {\n    return this.group;\n  }\n\n  public getField() {\n    return this.field;\n  }\n\n  public getCount() {\n    return this.count;\n  }\n\n  public getOptions() {\n    return this.options;\n  }\n\n  public get() {\n    return this.current;\n  }\n\n  public isArray() {\n    return this.array;\n  }\n\n  public isMulti() {\n    return this.multi;\n  }\n\n  /**\n   * Builds up the filter string from the current filter and it's children.\n   */\n  public filter() {\n    const options = this.current\n      .map((c) => {\n        let f = this.options[c];\n        if (isFunction(f)) {\n          f = f();\n        }\n        if (!isEmpty(f)) {\n          f = escapeValue(f);\n        }\n        if (this.count && f === undefined && c) {\n          f = this.array ? `${this.field} ~ [\"${c}\"]` : `${this.field} = \"${c}\"`;\n        }\n        return f;\n      })\n      .filter(Boolean);\n\n    if (options.length < 2) {\n      return options.join('');\n    }\n\n    return options.map((f) => `(${f})`).join(` ${this.joinOperator} `);\n  }\n\n  public getBuckets() {\n    return Object.entries(this.options)\n      .map(([key, value]) => `${this.name}_${key}:${value}`)\n      .join(',');\n  }\n\n  /**\n   * Reset the current filter to the initial one\n   */\n  public reset() {\n    this.current = [...this.initial];\n    this.emitSelectionUpdated();\n  }\n\n  /**\n   * Emits a selection updated event to the selection updated listener.\n   * @private\n   */\n  protected emitSelectionUpdated() {\n    this.listeners[EVENT_SELECTION_UPDATED].notify((listener) => {\n      listener();\n    });\n  }\n\n  /**\n   * Emits an options updated event to the options updated listener.\n   * @private\n   */\n  protected emitOptionsUpdated() {\n    this.listeners[EVENT_OPTIONS_UPDATED].notify((listener) => {\n      listener();\n    });\n  }\n}\n","import { isArray, round, roundToStep } from '@sajari/react-sdk-utils';\n\nimport { EVENT_RANGE_UPDATED } from '../../events';\nimport { Listener } from '../Listener';\nimport { Range, RangeFilterOptions } from './types';\n\nconst events = [EVENT_RANGE_UPDATED];\n\nexport default class RangeFilterBuilder {\n  private initial: Range | null;\n\n  private range: Range | null;\n\n  private name: string;\n\n  private group: string | undefined;\n\n  private field: string;\n\n  private min: number;\n\n  private max: number;\n\n  private step: number;\n\n  private aggregate: boolean;\n\n  private listeners: { [k: string]: Listener };\n\n  private formatter: Required<RangeFilterOptions>['formatter'];\n\n  constructor({\n    field,\n    name,\n    group,\n    aggregate = true,\n    initial,\n    min = 0,\n    max = aggregate ? 0 : 100,\n    step = 1,\n    formatter = (value: Range) => value.map((v) => roundToStep(v, step)) as Range,\n  }: RangeFilterOptions) {\n    if (typeof initial === 'undefined') {\n      this.initial = aggregate ? null : [min, max];\n    } else {\n      this.initial = initial;\n    }\n\n    this.range = this.initial;\n    this.name = name;\n    this.group = group;\n    this.field = field;\n    this.formatter = formatter;\n    this.min = min;\n    this.max = max;\n    this.step = step;\n    this.aggregate = aggregate;\n    this.listeners = {\n      [EVENT_RANGE_UPDATED]: new Listener(),\n    };\n  }\n\n  /**\n   * Register a listener for a specific event.\n   */\n  public listen(event: string, callback: (filter: RangeFilterBuilder) => void): () => void {\n    if (!events.includes(event)) {\n      throw new Error(`Unknown event type \"${event}\"`);\n    }\n\n    return this.listeners[event].listen(callback);\n  }\n\n  public get() {\n    return this.range;\n  }\n\n  public set(range: Range | null, emitEvent = true) {\n    this.range = range ? this.formatter(range) : range;\n\n    if (emitEvent) {\n      this.emitRangeUpdated();\n    }\n  }\n\n  public getName() {\n    return this.name;\n  }\n\n  public getGroup() {\n    return this.group;\n  }\n\n  public getField() {\n    return this.field;\n  }\n\n  public setMin(value: number) {\n    this.min = value;\n  }\n\n  public setMax(value: number) {\n    this.max = value;\n  }\n\n  public getMinMax() {\n    return [this.min, this.max];\n  }\n\n  public getStep() {\n    return this.step;\n  }\n\n  /**\n   * Builds up the filter string from the current state.\n   */\n  public filter() {\n    if (!this.range) {\n      return '';\n    }\n\n    return `${this.field} >= ${this.range[0]} AND ${this.field} <= ${this.range[1]}`;\n  }\n\n  public isAggregate() {\n    return this.aggregate;\n  }\n\n  /**\n   * Check if the current range is different to the initial value\n   */\n  public hasChanged() {\n    if (!this.range || !this.initial) {\n      return this.range === this.initial;\n    }\n\n    return this.range[0] !== this.initial[0] || this.range[1] !== this.initial[1];\n  }\n\n  /**\n   * Reset the current state to the initial value\n   */\n  public reset(emitEvent = true) {\n    this.range = isArray(this.initial) ? [...this.initial] : this.initial;\n\n    if (emitEvent) {\n      this.emitRangeUpdated();\n    }\n  }\n\n  public format(value: Range) {\n    return this.formatter(value);\n  }\n\n  /**\n   * Emits a range updated event to the selection updated listener.\n   * @private\n   */\n  protected emitRangeUpdated() {\n    this.listeners[EVENT_RANGE_UPDATED].notify((listener) => {\n      listener(this);\n    });\n  }\n}\n","import { groupBy, isEmpty } from '@sajari/react-sdk-utils';\n\nimport FilterBuilder from './FilterBuilder';\nimport RangeFilterBuilder from './RangeFilterBuilder';\n\ntype Type = 'filter' | 'countFilters';\n\n// Group expressions into an ARRAY_MATCH\nconst buildArrayMatch = (expressions: Array<string>) => {\n  let list = expressions.filter(Boolean);\n\n  if (list.length > 1) {\n    list = list.map((expression) => `(${expression})`);\n  }\n\n  return `ARRAY_MATCH(${list.join(' AND ')})`;\n};\n\n// Group filters together using ARRAY_MATCH\nexport function groupFilters(\n  filters: Array<FilterBuilder | RangeFilterBuilder>,\n  type: Type,\n  joinOperator: string,\n): string {\n  let list = filters.map((f) => ({\n    group: f.getGroup(),\n    field: f.getField(),\n    expression: f.filter(),\n    count: f instanceof FilterBuilder && f.getCount(),\n  }));\n\n  // For filter we only want defined expressions\n  if (type === 'filter') {\n    list = list.filter(({ expression }) => Boolean(expression));\n  }\n\n  // Group and flatten the filter expressions into groups\n  const groups = Object.entries(groupBy(list, 'group'))\n    .filter(([group]) => Boolean(group))\n    .reduce(\n      (out, [key, f]: [string, typeof list]) => ({\n        ...out,\n        [key]: f.map(({ expression }) => expression),\n      }),\n      {},\n    ) as Record<string, Array<string>>;\n\n  // Build filter expression\n  if (type === 'filter') {\n    // Build the list of non grouped filters\n    const basicFilters = list.filter(({ group, count }) => !group && !count).map(({ expression }) => `(${expression})`);\n\n    return Object.entries(groups)\n      .reduce((out, [group, expressions]) => {\n        if (group !== 'undefined' && !isEmpty(expressions)) {\n          return [...out, buildArrayMatch(expressions)];\n        }\n\n        return out;\n      }, [])\n      .concat(...basicFilters)\n      .join(joinOperator);\n  }\n\n  // Build countFilters expression (has to be one item per filter)\n  return list\n    .filter(({ field, count }) => !isEmpty(field) && count)\n    .map(({ group, expression, count }) => {\n      if (group && !isEmpty(groups[group])) {\n        return buildArrayMatch(groups[group]);\n      }\n\n      return count ? expression : null;\n    })\n    .filter((e) => e !== null)\n    .join(joinOperator);\n}\n","import { EVENT_OPTIONS_UPDATED, EVENT_RANGE_UPDATED, EVENT_SELECTION_UPDATED } from '../../events';\nimport { Listener } from '../Listener';\nimport FilterBuilder from './FilterBuilder';\nimport RangeFilterBuilder from './RangeFilterBuilder';\nimport { JoinOperator } from './types';\nimport { groupFilters } from './utils';\n\nconst events = [EVENT_SELECTION_UPDATED, EVENT_OPTIONS_UPDATED, EVENT_RANGE_UPDATED];\n\n/**\n * CombineFilters is a helper for combining multiple Filter instances\n * into one.\n *\n * Whenever any of the combined filters are updated, the events are\n * propagated up to the returned \"root\" filter.\n *\n * @param filters Array of filters to combine.\n * @param  [joinOperator=\"AND\"] Operator to apply between them (\"AND\" | \"OR\").\n * @return The resulting Filter.\n */\nexport default function combineFilters(\n  filters: (FilterBuilder | RangeFilterBuilder)[],\n  joinOperator: JoinOperator = 'AND',\n) {\n  const listeners = {\n    [EVENT_SELECTION_UPDATED]: new Listener(),\n    [EVENT_OPTIONS_UPDATED]: new Listener(),\n    [EVENT_RANGE_UPDATED]: new Listener(),\n  };\n  const removeListenerFuncs: (() => void)[] = [];\n\n  function listen(event: string, callback: (filter: FilterBuilder) => void): () => void {\n    if (events.indexOf(event) === -1) {\n      throw new Error(`Unknown event type \"${event}\"`);\n    }\n    return listeners[event].listen(callback);\n  }\n\n  filters.forEach((f) => {\n    if (f instanceof FilterBuilder) {\n      removeListenerFuncs.push(\n        f.listen(EVENT_SELECTION_UPDATED, () => {\n          listeners[EVENT_SELECTION_UPDATED].notify((listener) => {\n            listener(f);\n          });\n        }),\n        f.listen(EVENT_OPTIONS_UPDATED, () => {\n          listeners[EVENT_OPTIONS_UPDATED].notify((listener) => {\n            listener(f);\n          });\n        }),\n      );\n    }\n    if (f instanceof RangeFilterBuilder) {\n      removeListenerFuncs.push(\n        f.listen(EVENT_RANGE_UPDATED, () => {\n          listeners[EVENT_RANGE_UPDATED].notify((listener) => {\n            listener(f);\n          });\n        }),\n      );\n    }\n  });\n\n  function removeChildFilterListeners() {\n    removeListenerFuncs.forEach((fn) => fn());\n  }\n\n  // Generate filter field from non aggregate count Filter(s) for Variables object\n  const filter = () => groupFilters(filters, 'filter', ` ${joinOperator} `);\n\n  // Generate buckets field from non aggregate count Filter(s) for Variables object\n  const buckets = () =>\n    filters\n      .filter((f) => f instanceof FilterBuilder && !f.getCount())\n      .map((f) => f instanceof FilterBuilder && f.getBuckets())\n      .filter(Boolean)\n      .join(',');\n\n  // Generate countFilters field from aggregate count Filter(s) for Variables object\n  const countFilters = () => groupFilters(filters, 'countFilters', ',');\n\n  // Generate count field from aggregate count Filter(s) for Variables object\n  const count = () =>\n    filters\n      .filter((f) => f instanceof FilterBuilder && f.getCount())\n      .map((f) => f instanceof FilterBuilder && f.getField())\n      .filter(Boolean)\n      .join(',');\n\n  // Generate min field from range Filter(s) for Variables object\n  const min = () =>\n    filters\n      .filter((f) => f instanceof RangeFilterBuilder && f.isAggregate())\n      .map((f) => f.getField())\n      .join(',');\n\n  // Generate max field from range Filter(s) for Variables object\n  const max = () =>\n    filters\n      .filter((f) => f instanceof RangeFilterBuilder && f.isAggregate())\n      .map((f) => f.getField())\n      .join(',');\n\n  return { filter, listen, buckets, countFilters, count, removeChildFilterListeners, max, min };\n}\n","import { Aggregates, RequestError, Result } from '@sajari/sdk-js';\n\nexport type ResponseMap = Map<string, number | Aggregates | Result[]>;\n\nexport class Response {\n  private error: RequestError | null;\n\n  private queryValues?: Map<string, string>;\n\n  private response?: ResponseMap;\n\n  private values?: Map<string, string>;\n\n  /**\n   * Constructs a Response object.\n   * @param error\n   * @param queryValues\n   * @param response\n   * @param values\n   */\n  constructor(\n    error: RequestError | null,\n    queryValues?: Map<string, string>,\n    response?: ResponseMap,\n    values?: Map<string, string>,\n  ) {\n    this.error = error;\n    this.queryValues = queryValues;\n    this.response = response;\n    this.values = values;\n  }\n\n  /**\n   * Is this response empty?\n   */\n  public isEmpty(): boolean {\n    return (\n      this.error === null && this.response === undefined && this.values === undefined && this.queryValues === undefined\n    );\n  }\n\n  /**\n   * Is this response an error?\n   */\n  public isError(): boolean {\n    return this.error !== null;\n  }\n\n  /**\n   * The error associated with this response.\n   */\n  public getError(): RequestError | null {\n    return this.error;\n  }\n\n  /**\n   * Return the query values used in the search which created this response.\n   */\n  public getQueryValues(): Map<string, string> | undefined {\n    return this.queryValues;\n  }\n\n  /**\n   * Returns the response, which includes results and aggregates etc.\n   */\n  public getResponse(): ResponseMap | undefined {\n    return this.response;\n  }\n\n  /**\n   * Return the pipeline values returned by the search.\n   */\n  public getValues(): Map<string, string> | undefined {\n    return this.values;\n  }\n\n  /**\n   * Return results from the response.\n   */\n  public getResults(): Result[] | undefined {\n    return this.response !== undefined ? (this.response.get('results') as Result[]) : undefined;\n  }\n\n  /**\n   * Return the total number of results.\n   */\n  public getTotalResults(): number | undefined {\n    return this.response !== undefined ? (this.response.get('totalResults') as number) : undefined;\n  }\n\n  /**\n   * Return time from the response.\n   */\n  public getTime(): number | undefined {\n    return this.response !== undefined ? (this.response.get('time') as number) : undefined;\n  }\n\n  /**\n   * Return the aggregates in the response.\n   */\n  public getAggregates(): Aggregates | undefined {\n    if (this.response === undefined) {\n      return undefined;\n    }\n\n    const aggregates = this.response.get('aggregates');\n    if (aggregates === undefined) {\n      return undefined;\n    }\n    return aggregates as Aggregates;\n  }\n\n  /**\n   * Return the aggregateFilters in the response.\n   */\n  public getAggregateFilters(): Aggregates | undefined {\n    if (this.response === undefined) {\n      return undefined;\n    }\n\n    const aggregates = this.response.get('aggregateFilters');\n    if (aggregates === undefined) {\n      return undefined;\n    }\n    return aggregates as Aggregates;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable class-methods-use-this */\n/* eslint-disable no-underscore-dangle */\nimport { Session } from '@sajari/sdk-js';\n\nimport { EVENT_TRACKING_RESET } from '../../events';\nimport { CallbackFn, Listener, ListenerMap, UnlistenFn } from '../Listener';\n\nconst events = [EVENT_TRACKING_RESET];\n\nexport type TrackingValues = Record<string, string>;\n\nexport class Tracking {\n  public clientTracking: Session | null = null;\n\n  private listeners: ListenerMap;\n\n  public field: string;\n\n  constructor() {\n    this.listeners = new Map(\n      Object.entries({\n        [EVENT_TRACKING_RESET]: new Listener(),\n      }),\n    );\n  }\n\n  /**\n   * Register a listener for a specific event.\n   * @param event Event to listen for\n   * @param callback Callback to run when the event happens.\n   * @return The unregister function to remove the callback from the listener.\n   */\n  public listen(event: string, callback: CallbackFn): UnlistenFn {\n    if (events.indexOf(event) === -1) {\n      throw new Error(`Unknown event type \"${event}\"`);\n    }\n    return (this.listeners.get(event) as Listener).listen(callback);\n  }\n\n  /**\n   * Emits a tracking reset event to the tracking reset event listener.\n   */\n  private emitTrackingReset(values: TrackingValues) {\n    (this.listeners.get(EVENT_TRACKING_RESET) as Listener).notify((listener) => {\n      listener(values);\n    });\n  }\n\n  /**\n   * Reset the tracking.\n   * @param variables Key-value pair parameters to use in the pipeline.\n   */\n  public reset(variables?: TrackingValues) {\n    (this.clientTracking as Session).reset();\n\n    if (variables !== undefined) {\n      // eslint-disable-next-line no-underscore-dangle\n      this.emitTrackingReset(variables);\n    }\n  }\n\n  /**\n   * Construct a tracking session to be used in a search.\n   * @param variables Key-value pair parameters to use in the pipeline.\n   */\n  public next(variables: TrackingValues) {\n    if (this.clientTracking === null) {\n      throw new Error('clientTracking is null');\n    }\n\n    return this.clientTracking.next(variables);\n  }\n}\n","import Cookies from 'js-cookie';\n\nexport const getTrackingData = () => {\n  const data = {} as { [k: string]: string };\n  const ga = Cookies.get('_ga');\n  if (ga) {\n    data.ga = ga;\n  }\n  const sjID = Cookies.get('sjID');\n  if (sjID) {\n    data.sjID = sjID;\n  }\n  return data;\n};\n","import { DefaultSession, InteractiveSession, TrackingType } from '@sajari/sdk-js';\n\nimport { Tracking } from './Tracking';\nimport { getTrackingData } from './utils';\n\nexport class ClickTracking extends Tracking {\n  /**\n   * Construct a ClickTracking instance.\n   * @param field Field to use for click token generation.\n   * @param qParam Value to use for full-text query param.\n   */\n  constructor(field = 'url', qParam = 'q') {\n    super();\n\n    this.field = field;\n    this.clientTracking = new InteractiveSession(\n      qParam,\n      new DefaultSession(TrackingType.Click, this.field, getTrackingData()),\n    );\n  }\n}\n","import { DefaultSession, TrackingType } from '@sajari/sdk-js';\n\nimport { Tracking } from './Tracking';\nimport { getTrackingData } from './utils';\n\nexport class NoTracking extends Tracking {\n  /**\n   * Construct a NoTracking instance.\n   */\n  constructor() {\n    super();\n\n    this.field = '_id';\n    this.clientTracking = new DefaultSession(TrackingType.None, this.field, getTrackingData());\n  }\n}\n","import { DefaultSession, TrackingType } from '@sajari/sdk-js';\n\nimport { Tracking } from './Tracking';\nimport { getTrackingData } from './utils';\n\nexport class PosNegTracking extends Tracking {\n  /**\n   * Construct a PosNegTracking instance.\n   * @param field Field to use for click token generation.\n   */\n  constructor(field = 'url') {\n    super();\n\n    this.field = field;\n    this.clientTracking = new DefaultSession(TrackingType.PosNeg, this.field, getTrackingData());\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { isSSR, isString } from '@sajari/react-sdk-utils';\nimport { Client } from '@sajari/sdk-js';\n\nimport { EVENT_RESPONSE_UPDATED, EVENT_RESULT_CLICKED, EVENT_SEARCH_SENT } from '../events';\nimport { Analytics, GoogleAnalytics } from './analytics';\nimport { CallbackFn, Listener, ListenerMap, UnlistenFn } from './Listener';\nimport { Response } from './Response';\nimport { ClickTracking, NoTracking, PosNegTracking } from './tracking';\n\nconst events = [EVENT_SEARCH_SENT, EVENT_RESPONSE_UPDATED, EVENT_RESULT_CLICKED];\n\ntype QueryPipeline = ReturnType<Client['pipeline']>;\n\nexport class Pipeline {\n  public config: {\n    account: string;\n    collection: string;\n    endpoint?: string;\n    key?: string;\n    secret?: string;\n  };\n\n  private pipeline: QueryPipeline;\n\n  private client: Client;\n\n  private tracking: ClickTracking | PosNegTracking | NoTracking;\n\n  private listeners: ListenerMap;\n\n  private searchCount: number;\n\n  private response: Response = new Response(null);\n\n  private analytics: Analytics;\n\n  /**\n   * Constructs a Pipeline object.\n   * @param config Account, Collection config\n   * @param name Name of the pipeline.\n   * @param tracking Default tracking to use in searches.\n   * @param analyticsAdapters\n   */\n  constructor(\n    config: {\n      account: string;\n      collection: string;\n      endpoint?: string;\n      key?: string;\n      secret?: string;\n    },\n    name: string | { name: string; version?: string },\n    tracking: ClickTracking | PosNegTracking | NoTracking = new NoTracking(),\n    analyticsAdapters = [GoogleAnalytics],\n  ) {\n    const { account, collection, endpoint, key, secret } = config;\n    this.config = config;\n\n    const p: { name?: string; version?: string } = {\n      name: undefined,\n      version: undefined,\n    };\n    if (isString(name)) {\n      p.name = name;\n    } else if ('name' in name) {\n      p.name = name.name;\n      p.version = name.version;\n    }\n\n    // Only use key/secret in SSR contexts\n    if (isSSR()) {\n      this.client = new Client(account, collection, endpoint, key, secret);\n    } else {\n      this.client = new Client(account, collection, endpoint);\n    }\n\n    this.pipeline = this.client.pipeline(p.name as string, p.version);\n    this.tracking = tracking;\n    this.listeners = new Map([\n      [EVENT_SEARCH_SENT, new Listener()],\n      [EVENT_RESPONSE_UPDATED, new Listener()],\n      [EVENT_RESULT_CLICKED, new Listener()],\n    ]);\n    this.searchCount = 0;\n    this.response = new Response(null);\n\n    this.analytics = new Analytics(this, this.tracking);\n    analyticsAdapters.forEach((Adapter) => {\n      // eslint-disable-next-line no-new\n      new Adapter(this.analytics);\n    });\n  }\n\n  /**\n   * Register a listener for a specific event.\n   * @param event Event to listen for\n   * @param callback Callback to run when the event happens.\n   * @return The unregister function to remove the callback from the listener.\n   */\n  public listen(event: string, callback: CallbackFn): UnlistenFn {\n    if (events.indexOf(event) === -1) {\n      throw new Error(`Unknown event type \"${event}\"`);\n    }\n    return (this.listeners.get(event) as Listener).listen(callback);\n  }\n\n  /**\n   * Emits a search event to the search event listener.\n   * @private\n   */\n  public _emitSearchSent(variables: { [k: string]: string }): void {\n    (this.listeners.get(EVENT_SEARCH_SENT) as Listener).notify((listener) => {\n      listener(variables);\n    });\n  }\n\n  /**\n   * Emits a results event to the results event listener.\n   * @private\n   */\n  public _emitResponseUpdated(response: Response): void {\n    (this.listeners.get(EVENT_RESPONSE_UPDATED) as Listener).notify((listener) => {\n      listener(response);\n    });\n  }\n\n  /**\n   * Emits a result clicked event to the results clicked event listeners.\n   * @param value Value to send to the listeners.\n   */\n  public emitResultClicked(value: string): void {\n    (this.listeners.get(EVENT_RESULT_CLICKED) as Listener).notify((listener) => {\n      listener(value);\n    });\n  }\n\n  /**\n   * Perform a search.\n   * @param variables Key-value parameters to pass to the pipeline.\n   */\n  public search(variables: { [k: string]: string }): void {\n    this.searchCount += 1;\n    const currentSearch = this.searchCount;\n\n    this.pipeline\n      .search(variables, this.tracking.next(variables))\n      .then(([response, responseValues]) => {\n        if (currentSearch < this.searchCount) {\n          return;\n        }\n\n        this.response = new Response(\n          null,\n          new Map(Object.entries(variables)),\n          new Map(Object.entries(response)),\n          new Map(Object.entries(responseValues)),\n        );\n      })\n      .catch((error) => {\n        // TODO: Should we have a debug option to enable console logging?\n        // eslint-disable-next-line no-console\n        console.error(error);\n\n        if (currentSearch < this.searchCount) {\n          return;\n        }\n\n        this.response = new Response(error, new Map(Object.entries(variables)), undefined, undefined);\n      })\n      .finally(() => {\n        this._emitResponseUpdated(this.response);\n      });\n    this._emitSearchSent(variables);\n  }\n\n  /**\n   * Clears the error, response, and response variables from this object.\n   * @param variables Key-value pair parameters.\n   */\n  public clearResponse(variables: { [k: string]: string }): void {\n    this.tracking.next(variables);\n    this.searchCount += 1;\n    this.response = new Response(null);\n    this._emitResponseUpdated(this.response);\n  }\n\n  /**\n   * The current response.\n   */\n  public getResponse(): Response {\n    return this.response;\n  }\n\n  /**\n   * The analytics adaptor connected to this pipeline.\n   */\n  public getAnalytics(): Analytics {\n    return this.analytics;\n  }\n\n  /**\n   * The underlying client\n   */\n  public getClient(): Client {\n    return this.client;\n  }\n\n  /**\n   * The tracking instance\n   */\n  public getTracking(): ClickTracking | PosNegTracking | NoTracking {\n    return this.tracking;\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { defaultConfig } from '../Config';\nimport { EVENT_VALUES_UPDATED } from '../events';\nimport { Listener, ListenerMap } from './Listener';\n\nexport type VariableFn = () => string;\nexport type VariablesMap = Map<string, string | string[] | number | boolean | VariableFn>;\nexport interface VariablesObject {\n  [k: string]: string | string[] | number | boolean | VariableFn | undefined;\n}\nexport type CallbackFn = (variables: VariablesObject, set: (variables: VariablesObject) => void) => void;\n\nexport class Variables {\n  private variables: VariablesMap;\n\n  private listeners: ListenerMap;\n\n  /**\n   * Constructor for Variables object.\n   * @param variables Initial variables.\n   */\n  constructor(variables: { [k: string]: string | string[] | number | boolean | VariableFn } = {}) {\n    this.listeners = new Map([[EVENT_VALUES_UPDATED, new Listener()]]);\n    this.variables = new Map(\n      Object.entries({\n        [defaultConfig.qParam]: '',\n        [defaultConfig.resultsPerPageParam]: 15,\n        ...variables,\n      }),\n    );\n  }\n\n  /**\n   * Register a listener for a specific event.\n   * @param event Event to listen for\n   * @param callback Callback to run when the event happens.\n   */\n  public listen(event: string, callback: CallbackFn) {\n    if (event !== EVENT_VALUES_UPDATED) {\n      throw new Error(`Unknown event type \"${event}\"`);\n    }\n    return (this.listeners.get(event) as Listener).listen(callback);\n  }\n\n  /**\n   * Merge variables into the variable map.\n   *\n   * Set a variable to undefined to remove it.\n   */\n  public set(variables: VariablesObject) {\n    this._set(variables);\n    this._emitUpdated(variables);\n  }\n\n  /**\n   * get returns the current variables.\n   */\n  public get(): { [k: string]: string } {\n    const variables = {} as { [k: string]: string };\n\n    this.variables.forEach((variable, key) => {\n      if (typeof variable === 'function') {\n        variables[key] = variable();\n      } else if (Array.isArray(variable)) {\n        variables[key] = variable.join(',');\n      } else {\n        variables[key] = String(variable);\n      }\n    });\n    return variables;\n  }\n\n  /**\n   * Emits an event to notify listener that the variables have been updated.\n   *\n   * @private\n   */\n  private _emitUpdated(changes: VariablesObject) {\n    (this.listeners.get(EVENT_VALUES_UPDATED) as Listener).notify((listener) =>\n      listener(changes, (variables: VariablesObject) => this._set(variables)),\n    );\n  }\n\n  /**\n   * Sets variables without triggering an event, internal use only.\n   */\n  private _set(variables: VariablesObject) {\n    Object.keys(variables).forEach((key) => {\n      if (variables[key] === undefined) {\n        this.variables.delete(key);\n      } else {\n        this.variables.set(key, variables[key] as string | VariableFn);\n      }\n    });\n  }\n}\n","/* eslint-disable import/named */\n/* eslint-disable @typescript-eslint/no-shadow */\nimport { createContext, isEmpty, isString } from '@sajari/react-sdk-utils';\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\n\nimport { Config, defaultConfig } from './Config';\nimport {\n  ClickTracking,\n  FilterBuilder,\n  FilterOptions,\n  Pipeline,\n  PosNegTracking,\n  Range,\n  RangeFilterBuilder,\n  RangeFilterOptions,\n  Response,\n  Variables,\n} from './controllers';\nimport combineFilters from './controllers/filters/combineFilters';\nimport { UnlistenFn } from './controllers/Listener';\nimport { EVENT_RANGE_UPDATED, EVENT_RESPONSE_UPDATED, EVENT_SELECTION_UPDATED, EVENT_VALUES_UPDATED } from './events';\nimport {\n  Context,\n  FieldDictionary,\n  PipelineProviderState,\n  ProviderPipelineConfig,\n  ProviderPipelineState,\n  SearchProviderValues,\n} from './types';\n\nconst updateState = (query: string, responseValues: Map<string, string> | undefined, config: Config) => {\n  const completion = query && responseValues ? responseValues.get(config.qParam) || '' : '';\n  let suggestions: string[] = [];\n  if (responseValues) {\n    suggestions = (responseValues.get(config.qSuggestionsParam) || '')\n      .split(',')\n      .filter((s) => s.length > 0)\n      .slice(0, config.maxSuggestions);\n  }\n\n  return {\n    completion,\n    query,\n    suggestions,\n  };\n};\n\nconst responseUpdatedListener = (variables: Variables, config: Config, response: Response) => {\n  const query = variables.get()[config.qParam] || '';\n  const responseValues = response.getValues();\n\n  return updateState(query, responseValues, config);\n};\n\nconst valuesUpdatedListener = (variables: Variables, pipeline: Pipeline, config: Config) => {\n  const query = variables.get()[config.qParam] || '';\n  const responseValues = pipeline.getResponse().getValues();\n\n  return updateState(query, responseValues, config);\n};\n\nconst [Provider, useContext] = createContext<Context>({\n  strict: true,\n  name: 'PipelineContext',\n});\n\nconst defaultState: ProviderPipelineState = {\n  response: null,\n  query: '',\n  completion: '',\n  suggestions: [],\n  config: defaultConfig,\n};\n\n// Map a serialized Response object back into a Response\nconst parseResponse = (initialResponse?: string) => {\n  if (!isString(initialResponse) || isEmpty(initialResponse)) {\n    return null;\n  }\n\n  const { queryValues = {}, response = {}, values = {} } = JSON.parse(initialResponse);\n\n  return new Response(\n    null,\n    new Map(Object.entries(queryValues)),\n    new Map(Object.entries(response)),\n    new Map(Object.entries(values)),\n  );\n};\n\nconst ContextProvider: React.FC<SearchProviderValues> = ({\n  children,\n  search,\n  autocomplete: autocompleteProp,\n  defaultFilter,\n  searchOnLoad,\n  initialResponse: initialResponseProp,\n}) => {\n  const initialResponse = parseResponse(initialResponseProp);\n  const [searching, setSearching] = useState(false);\n  const [autocompleteSearching, setAutocompleteSearching] = useState(false);\n  const [searchState, setSearchState] = useState({ ...defaultState, response: initialResponse });\n  const [autocompleteState, setAutocompleteState] = useState(defaultState);\n  const [configDone, setConfigDone] = useState(false);\n  const searchTimer = useRef<ReturnType<typeof setTimeout>>();\n  const searchAutocompleteTimer = useRef<ReturnType<typeof setTimeout>>();\n  const autocomplete = useRef(autocompleteProp);\n  const variables = useRef(search.variables ?? new Variables());\n  const autocompleteVariables = useRef(autocompleteProp?.variables ?? new Variables());\n  // Map the initial response\n  let response = search.pipeline.getResponse();\n  if (response.isEmpty() && initialResponse !== null) {\n    response = initialResponse;\n  }\n\n  if (!search.variables && !configDone) {\n    // For destructing down below (searchFn, clear, handlePaginate)\n    Object.assign(search, { variables: variables.current });\n  }\n  if (autocompleteProp && !autocompleteProp.variables && !configDone) {\n    // For destructing down below (searchFn, clear, handlePaginate)\n    Object.assign(autocompleteProp, { variables: autocompleteVariables.current });\n  }\n\n  if (!configDone) {\n    const filter = combineFilters(search.filters ?? []);\n    const variablesFilterString = variables.current.get().filter ?? '';\n    const defaultFilterString = defaultFilter?.toString() ?? '';\n\n    variables.current.set({\n      filter: () => {\n        const expression = filter.filter();\n        return [defaultFilterString, variablesFilterString, isEmpty(expression) ? '_id != \"\"' : expression]\n          .filter(Boolean)\n          .join(' AND ');\n      },\n      countFilters: () => filter.countFilters(),\n      buckets: () => filter.buckets(),\n      count: () => filter.count(),\n      min: () => filter.min(),\n      max: () => filter.max(),\n    });\n  }\n\n  const searchFn = useCallback(\n    (key: 'search' | 'autocomplete') => (inputQuery?: string, override = false) => {\n      const func = key === 'autocomplete' ? autocomplete.current : search;\n      const state = key === 'autocomplete' ? autocompleteState : searchState;\n      const setSearchingState = key === 'autocomplete' ? setAutocompleteSearching : setSearching;\n      const timer = key === 'autocomplete' ? searchAutocompleteTimer : searchTimer;\n      setSearchingState(true);\n      setSearchState((state) => ({ ...state, query: inputQuery ?? state.query }));\n      const { pipeline, variables } = func as Required<ProviderPipelineConfig>;\n      const { config } = state;\n\n      const text = {\n        [config.qParam]: inputQuery ?? variables.get()[config.qParam],\n        [config.qOverrideParam]: undefined,\n        [config.pageParam]: undefined,\n      };\n\n      // TODO(tuand): ask the backend the use of this property\n      if (override) {\n        text[config.qOverrideParam] = 'true';\n      }\n\n      variables.set(text);\n\n      if (timer.current) {\n        clearTimeout(timer.current);\n      }\n\n      timer.current = setTimeout(() => {\n        pipeline.search(variables.get());\n      }, 50);\n    },\n    [],\n  );\n\n  useEffect(() => {\n    const mergedConfig = { ...defaultConfig, ...search.config };\n\n    setSearchState((state) => ({\n      ...state,\n      response,\n      query: variables.current.get()[mergedConfig.qParam] || '',\n      config: mergedConfig,\n    }));\n\n    setAutocompleteState((state) => ({\n      ...state,\n      config: { ...defaultConfig, ...search.config },\n    }));\n\n    const unregisterFunctions: UnlistenFn[] = [];\n\n    if (search.filters) {\n      const filter = combineFilters(search.filters);\n\n      unregisterFunctions.push(\n        filter.listen(EVENT_SELECTION_UPDATED, () => searchFn('search')()),\n        filter.listen(EVENT_RANGE_UPDATED, () => searchFn('search')()),\n        filter.removeChildFilterListeners,\n      );\n    }\n\n    let searchRenderTimer: ReturnType<typeof setTimeout>;\n\n    unregisterFunctions.push(\n      search.pipeline.listen(EVENT_RESPONSE_UPDATED, (response: Response) => {\n        clearTimeout(searchRenderTimer);\n\n        searchRenderTimer = setTimeout(\n          () => {\n            setSearching(false);\n            setSearchState((prevState) => ({\n              ...prevState,\n              response,\n              ...responseUpdatedListener(variables.current, prevState.config, response),\n            }));\n          },\n          // Delay slightly longer if no results so if someone is typing they don't get a flash of no results\n          response.getResults()?.length === 0 ? 500 : 20,\n        );\n      }),\n    );\n\n    unregisterFunctions.push(\n      variables.current.listen(EVENT_VALUES_UPDATED, () =>\n        setSearchState((prevState) => ({\n          ...prevState,\n          ...valuesUpdatedListener(variables.current, search.pipeline, prevState.config),\n        })),\n      ),\n    );\n\n    if (!autocomplete.current) {\n      const { account, collection, endpoint } = search.pipeline.config;\n      autocomplete.current = {\n        pipeline: new Pipeline({ account, collection, endpoint }, 'autocomplete'),\n        variables: autocompleteVariables.current,\n      };\n    }\n\n    unregisterFunctions.push(\n      autocomplete.current.pipeline.listen(EVENT_RESPONSE_UPDATED, (response: Response) => {\n        setAutocompleteSearching(false);\n        setAutocompleteState((prevState) => ({\n          ...prevState,\n          response,\n          ...responseUpdatedListener(autocompleteVariables.current, prevState.config, response),\n        }));\n      }),\n    );\n\n    unregisterFunctions.push(\n      autocompleteVariables.current.listen(EVENT_VALUES_UPDATED, () =>\n        setAutocompleteState((prevState) => ({\n          ...prevState,\n          ...valuesUpdatedListener(\n            autocompleteVariables.current,\n            (autocomplete.current as ProviderPipelineConfig).pipeline,\n            prevState.config,\n          ),\n        })),\n      ),\n    );\n\n    if (searchOnLoad) {\n      search.pipeline.search(variables.current.get());\n    }\n\n    setConfigDone(true);\n\n    return () => {\n      unregisterFunctions.forEach((fn) => fn());\n    };\n  }, []);\n\n  const clear = useCallback(\n    (key: 'search' | 'autocomplete') => (vals?: { [k: string]: string | undefined }) => {\n      const func = key === 'autocomplete' ? autocomplete.current : search;\n      const { pipeline, variables } = func as Required<ProviderPipelineConfig>;\n\n      if (vals !== undefined) {\n        variables.set(vals);\n      }\n      pipeline.clearResponse(variables.get());\n    },\n    [],\n  );\n\n  const handlePaginate = useCallback(\n    (page: number) => {\n      const { pipeline, variables } = search as Required<ProviderPipelineConfig>;\n      const { config } = searchState;\n\n      variables.set({ [config.pageParam]: String(page) });\n      pipeline.search(variables.get());\n    },\n    [search.pipeline, search.variables, searchState.config],\n  );\n\n  const handleResultClicked = useCallback((url: string) => search.pipeline.emitResultClicked(url), []);\n\n  const getContext = (state: PipelineProviderState) =>\n    ({\n      ...state,\n      search: {\n        ...state.search,\n        variables: variables.current,\n        filters: search.filters,\n        pipeline: search.pipeline,\n        search: searchFn('search'),\n        clear: clear('search'),\n        fields: search.fields,\n        searching,\n      },\n      autocomplete: {\n        ...state.autocomplete,\n        variables: autocompleteVariables.current,\n        filters: search.filters,\n        pipeline: autocomplete.current?.pipeline,\n        search: searchFn('autocomplete'),\n        clear: clear('autocomplete'),\n        fields: autocomplete.current?.fields,\n        searching: autocompleteSearching,\n      },\n      resultClicked: handleResultClicked,\n      paginate: handlePaginate,\n    } as Context);\n\n  return <Provider value={getContext({ autocomplete: autocompleteState, search: searchState })}>{children}</Provider>;\n};\n\nexport default ContextProvider;\nexport {\n  ClickTracking,\n  combineFilters,\n  Config,\n  FieldDictionary,\n  FilterBuilder,\n  FilterOptions,\n  Pipeline,\n  PosNegTracking,\n  Range,\n  RangeFilterBuilder,\n  RangeFilterOptions,\n  Response,\n  useContext,\n  Variables,\n};\nexport type { SearchProviderValues };\n","import { isSSR } from '@sajari/react-sdk-utils';\n\nimport { SortType } from './types';\n\nconst priceRangePattern = /\\d+\\s-\\s\\d+/gm;\nconst patternTest = priceRangePattern.test.bind(priceRangePattern);\nconst collator = new Intl.Collator(!isSSR() ? window.navigator.language : 'en-US', {\n  numeric: true,\n});\n\nexport type Item = [string, number | string | (() => string)];\n\n// Add support to sort price range (\"1 - 50\", \"200 - 500\" or \"> 2000\")\nexport const sortItems = (list: Item[], sort: SortType = 'alpha', asc = true) => {\n  if (sort === 'none') {\n    return list;\n  }\n\n  const byLabel = sort !== 'count';\n\n  return [...list].sort(([labelLeft, valueLeft], [labelRight, valueRight]) => {\n    const left = String(byLabel ? labelLeft : valueLeft);\n    const right = String(byLabel ? labelRight : valueRight);\n    // for price range\n    switch (true) {\n      case [left, right].every(patternTest): {\n        const minLeft = left.split(' - ').map(Number)[0];\n        const minRight = right.split(' - ').map(Number)[0];\n        if (asc) {\n          return collator.compare(String(minLeft), String(minRight));\n        }\n        return collator.compare(String(minRight), String(minLeft));\n      }\n      case left.startsWith('>'):\n      case right.startsWith('<'):\n        return asc ? 1 : -1;\n      case left.startsWith('<'):\n      case right.startsWith('>'):\n        return asc ? -1 : 1;\n      default:\n        break;\n    }\n\n    if (asc) {\n      return collator.compare(String(left), String(right));\n    }\n    return collator.compare(String(right), String(left));\n  });\n};\n","import { useCallback, useMemo } from 'react';\n\nimport { useContext } from '../ContextProvider';\nimport { UsePaginationResult } from './types';\n\nfunction usePagination(key: 'search' | 'autocomplete' = 'search'): UsePaginationResult {\n  const context = useContext();\n  const { paginate } = context;\n  const { response, config } = context[key];\n  const queryValues = response?.getQueryValues();\n  const page = queryValues?.get(config.pageParam) ? parseInt(queryValues.get(config.pageParam) as string, 10) : 1;\n  const resultsPerPage = queryValues?.get(config.resultsPerPageParam)\n    ? parseInt(queryValues?.get(config.resultsPerPageParam) as string, 10)\n    : 15;\n  const totalResults = response?.getTotalResults() || 0;\n  const totalPages = Math.ceil(totalResults / resultsPerPage);\n  const hasNext = useMemo(() => page < totalPages, [page, totalPages]);\n  const hasPrevious = useMemo(() => page > 1, [page]);\n  const nextPage = useCallback(() => hasNext && paginate(page + 1), [paginate, hasNext]);\n  const previousPage = useCallback(() => hasPrevious && paginate(page - 1), [paginate, hasPrevious]);\n\n  return {\n    page,\n    pageCount: totalPages,\n    totalResults,\n    setPage: paginate,\n    resultsPerPage,\n    hasNext,\n    hasPrevious,\n    nextPage,\n    previousPage,\n  };\n}\n\nexport default usePagination;\nexport * from './types';\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Config } from './Config';\nimport { FilterBuilder, Pipeline, RangeFilterBuilder, Response, Variables } from './controllers';\n\nexport type SearchFn = (query?: string, override?: boolean) => void;\nexport type ClearFn = (variables?: { [k: string]: string | undefined }) => void;\nexport type ResultClickedFn = (url: string) => void;\nexport type PaginateFn = (page: number) => void;\n\nexport interface PipelineContextState {\n  variables: Variables;\n  pipeline: Pipeline;\n  response: Response | null;\n  query: string;\n  completion: string;\n  suggestions: string[];\n  config: Config;\n  search: SearchFn;\n  clear: ClearFn;\n  fields?: FieldDictionary;\n  searching: boolean;\n  filters?: (FilterBuilder | RangeFilterBuilder)[];\n}\n\nexport interface ProviderPipelineConfig {\n  pipeline: Pipeline;\n  variables?: Variables;\n  config?: Config;\n  fields?: FieldDictionary;\n  filters?: (FilterBuilder | RangeFilterBuilder)[];\n}\n\nexport interface ProviderPipelineState {\n  response: Response | null;\n  query: string;\n  config: Config;\n  completion: string;\n  suggestions: string[];\n}\n\nexport interface SearchProviderValues {\n  search: ProviderPipelineConfig;\n  autocomplete?: ProviderPipelineConfig;\n  defaultFilter?: string;\n  searchOnLoad?: boolean;\n  initialResponse?: string;\n}\n\nexport interface PipelineProviderState {\n  search: ProviderPipelineState;\n  autocomplete: ProviderPipelineState;\n}\n\nexport interface Context {\n  search: PipelineContextState;\n  autocomplete: PipelineContextState;\n  resultClicked: ResultClickedFn;\n  paginate: PaginateFn;\n}\n\ntype Field = ((data: Record<string, any>) => any) | string | string[] | false;\nexport class FieldDictionary {\n  id?: Field;\n\n  url?: Field;\n\n  title?: Field;\n\n  subtitle?: Field;\n\n  description?: Field;\n\n  image?: Field;\n\n  // e-commerce related fields\n\n  price?: Field;\n\n  originalPrice?: Field;\n\n  rating?: Field;\n\n  constructor(input?: FieldDictionary) {\n    const {\n      id = '_id',\n      url = 'url',\n      title = 'title',\n      subtitle = 'url',\n      description = 'description',\n      image = 'image',\n      price = 'price',\n      originalPrice = 'originalPrice',\n      rating = 'rating',\n    } = input ?? {};\n\n    this.id = id;\n    this.url = url;\n    this.title = title;\n    this.subtitle = subtitle;\n    this.description = description;\n    this.image = image;\n    this.price = price;\n    this.originalPrice = originalPrice;\n    this.rating = rating;\n  }\n}\n","import { useContext } from '../ContextProvider';\n\nfunction useAutocomplete() {\n  const {\n    autocomplete: { suggestions, search, completion, searching },\n  } = useContext();\n\n  return {\n    suggestions,\n    search,\n    completion,\n    searching,\n  };\n}\n\nexport default useAutocomplete;\n","import { useEffect, useMemo, useState } from 'react';\n\nimport { FilterBuilder, useContext } from '../ContextProvider';\nimport { EVENT_SELECTION_UPDATED } from '../ContextProvider/events';\nimport { getBucketCount } from '../utils';\nimport { FilterItem, SortType } from './types';\nimport { sortItems } from './utils';\n\nfunction useFilter(name: string, params: { sort?: SortType; sortAscending?: boolean } = {}) {\n  const {\n    search: { filters = [], response },\n  } = useContext();\n\n  const filter = useMemo(\n    () => filters.filter((f) => f instanceof FilterBuilder && f.getName() === name)[0] as FilterBuilder,\n    [],\n  );\n\n  if (!filter) {\n    throw new Error(`Filter \"${name}\" doesn't exist.`);\n  }\n\n  const [selected, setInternalSelected] = useState(filter.get());\n\n  useEffect(() => {\n    const removeListener = filter.listen(EVENT_SELECTION_UPDATED, () => {\n      setInternalSelected(filter.get());\n    });\n\n    return () => {\n      removeListener();\n    };\n  }, []);\n\n  const setSelected = (value: string[], merge = false) => {\n    filter.set(value, merge);\n  };\n\n  const reset = () => {\n    filter.reset();\n  };\n\n  const { sort = 'alpha', sortAscending = sort !== 'count' } = params;\n\n  const options: FilterItem[] = useMemo(() => {\n    if (!response || response?.isEmpty()) {\n      return [];\n    }\n\n    const aggregates = response.getAggregates();\n    const aggregateFilters = response.getAggregateFilters();\n    const isCount = filter.getCount();\n    const field = filter.getField();\n\n    if (isCount && field) {\n      const array = filter.isArray();\n      let count = {};\n      ({ count } = (aggregateFilters || {})[field] || {});\n      if (!count) {\n        ({ count = {} } = (aggregates || {})[field] || {});\n      }\n\n      const temp = sortItems(Object.entries(count), sort, sortAscending)\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        .map(([label, count]: [string, number]) => ({\n          label,\n          count,\n          value: array ? `${field} ~ [\"${label}\"]` : `${field} = \"${label}\"`,\n        }));\n\n      filter.setOptions(temp.reduce((a, c) => ({ ...a, [c.label]: c.value }), {}));\n\n      return temp;\n    }\n\n    return sortItems(Object.entries(filter.getOptions()), sort, sortAscending).map(([label, value]) => {\n      const id = `${name}_${label}`;\n      const count = getBucketCount(response, id);\n\n      return { label, value, count } as FilterItem;\n    });\n  }, [JSON.stringify(response?.getResults())]);\n\n  return {\n    options,\n    setSelected,\n    selected,\n    reset,\n    multi: filter.isMulti(),\n  };\n}\n\nexport default useFilter;\nexport * from './types';\n","import { isNumber } from '@sajari/react-sdk-utils';\nimport { CountAggregate } from '@sajari/sdk-js';\n\nimport { Response } from '../ContextProvider';\n\nexport function getBucketCount(response: Response | null, value: string): number | null {\n  if (!response || response?.isEmpty()) {\n    return null;\n  }\n\n  let count: number | CountAggregate = 0;\n  const aggregates = response.getAggregates();\n  const aggregateFilters = response.getAggregateFilters();\n\n  if (aggregateFilters && Object.keys(aggregateFilters.buckets?.count ?? {}).includes(value)) {\n    ({ count } = aggregateFilters.buckets);\n  } else if (aggregates && Object.keys(aggregates.buckets?.count ?? {}).includes(value)) {\n    ({ count } = aggregates.buckets);\n  }\n\n  if (isNumber(count)) {\n    return 0;\n  }\n\n  return (count[value] as number) ?? 0;\n}\n","import * as React from 'react';\n\nimport { useContext } from '../ContextProvider';\n\nfunction useQuery() {\n  const {\n    search: { search, variables, query },\n  } = useContext();\n\n  const setQuery = React.useCallback(\n    (q: string) => {\n      variables.set({ q });\n      search(q);\n    },\n    [search, variables],\n  );\n\n  return { query, setQuery };\n}\n\nexport default useQuery;\n","import { isNullOrUndefined } from '@sajari/react-sdk-utils';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport { RangeFilterBuilder, useContext } from '../ContextProvider';\nimport { Range } from '../ContextProvider/controllers/filters/types';\nimport { EVENT_RANGE_UPDATED } from '../ContextProvider/events';\n\nfunction useRangeFilter(name: string) {\n  const {\n    search: { filters = [], response, query },\n  } = useContext();\n\n  const prevQuery = useRef<string | null>(null);\n  const selectionUpdated = useRef<boolean>(false);\n  const filter = useMemo(\n    () => filters.filter((f) => f instanceof RangeFilterBuilder && f.getName() === name)[0] as RangeFilterBuilder,\n    [],\n  );\n  const isAggregate = filter.isAggregate();\n  const limit = filter.getMinMax();\n\n  if (!filter) {\n    throw new Error(`Filter \"${name}\" doesn't exist.`);\n  }\n\n  const [range, setInternalRange] = useState(filter.get());\n  const [min, setMin] = useState<number>(limit[0]);\n  const [max, setMax] = useState<number>(limit[1]);\n\n  useEffect(() => {\n    // Ignore the componentDidMount trigger, only call after the query was changed\n    if (isAggregate && prevQuery.current !== null) {\n      filter.reset(false);\n    }\n  }, [query]);\n\n  useEffect(() => {\n    const removeListener = filter.listen(EVENT_RANGE_UPDATED, () => {\n      setInternalRange(filter.get());\n    });\n\n    return () => {\n      removeListener();\n    };\n  }, []);\n\n  const setRange = useCallback((value: Range) => {\n    filter.set(value);\n  }, []);\n\n  const showReset = useMemo(() => {\n    if (!range) {\n      return false;\n    }\n    if (isAggregate) {\n      return range[0] !== min || range[1] !== max;\n    }\n\n    return filter.hasChanged();\n  }, [range, min, max]);\n\n  const reset = () => {\n    if (isAggregate) {\n      filter.set([...filter.getMinMax()] as Range);\n    } else {\n      filter.reset();\n    }\n  };\n\n  useEffect(() => {\n    if (!isAggregate || prevQuery.current === query) {\n      prevQuery.current = query;\n      return;\n    }\n\n    if (!response || response?.isEmpty()) {\n      setMin(range ? range[0] : limit[0]);\n      setMax(range ? range[1] : limit[1]);\n      selectionUpdated.current = false;\n      return;\n    }\n\n    const field = filter.getField();\n    const aggregates = response.getAggregates();\n    const aggregateFilters = response.getAggregateFilters();\n    let newMin = 0;\n    let newMax = 0;\n    const aggregate = (aggregates || {})[field] || {};\n    const aggregateFilter = (aggregateFilters || {})[field] || {};\n\n    if (!isNullOrUndefined(aggregateFilter.min)) {\n      newMin = aggregateFilter.min as number;\n    } else if (!isNullOrUndefined(aggregate.min)) {\n      newMin = aggregate.min as number;\n    }\n\n    if (!isNullOrUndefined(aggregateFilter.max)) {\n      newMax = aggregateFilter.max as number;\n    } else if (!isNullOrUndefined(aggregate.max)) {\n      newMax = aggregate.max as number;\n    }\n\n    [newMin, newMax] = filter.format([newMin, newMax]);\n\n    setMin(newMin);\n    setMax(newMax);\n\n    // Set the filter\n    filter.setMin(newMin);\n    filter.setMax(newMax);\n\n    filter.set([newMin, newMax], false);\n    setInternalRange([newMin, newMax]);\n\n    prevQuery.current = query;\n  }, [JSON.stringify(response?.getResults())]);\n\n  return {\n    min,\n    max,\n    step: filter.getStep(),\n    setRange,\n    range,\n    reset,\n    showReset,\n  };\n}\n\nexport default useRangeFilter;\n","import { isNumber } from '@sajari/react-sdk-utils';\nimport * as React from 'react';\n\nimport { useContext } from '../ContextProvider';\nimport { UseResultsPerPageResult } from './types';\n\nfunction useResultsPerPage(): UseResultsPerPageResult {\n  const {\n    search: {\n      search,\n      config: { resultsPerPageParam },\n      variables,\n    },\n  } = useContext();\n\n  const setResultsPerPage = React.useCallback(\n    (size: number) => {\n      variables.set({ [resultsPerPageParam]: size });\n      search();\n    },\n    [variables, search],\n  );\n\n  const resultsPerPage = parseInt(variables.get()[resultsPerPageParam], 10);\n\n  return {\n    resultsPerPage: isNumber(resultsPerPage) ? resultsPerPage : 15,\n    setResultsPerPage,\n  };\n}\n\nexport default useResultsPerPage;\nexport * from './types';\n","/* eslint-disable @typescript-eslint/no-shadow */\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { useContext } from '../ContextProvider';\nimport { defaultConfig } from '../ContextProvider/Config';\nimport { Response } from '../ContextProvider/controllers';\nimport { EVENT_RESPONSE_UPDATED, EVENT_VALUES_UPDATED } from '../ContextProvider/events';\nimport { UseSearchConfig, UseSearchCustomConfig, UseSearchParams, UseSearchResult } from './types';\n\nfunction useCustomSearch({ pipeline, variables }: UseSearchCustomConfig): UseSearchResult {\n  const [searching, setSearching] = useState(false);\n  const searchFn = useCallback(\n    (q?: string) => {\n      setSearching(true);\n\n      if (q === '') {\n        pipeline.clearResponse(variables.get());\n      } else {\n        if (q) {\n          variables.set({ [defaultConfig.qParam]: q });\n        }\n        pipeline.search(variables.get());\n      }\n    },\n    [pipeline, variables],\n  );\n\n  const [searchOutput, setSearchOutput] = useState<Omit<UseSearchResult, 'searching'>>({\n    search: searchFn,\n    error: null,\n  });\n\n  useEffect(() => {\n    searchFn();\n\n    return pipeline.listen(EVENT_RESPONSE_UPDATED, (response: Response) => {\n      setSearching(false);\n\n      setSearchOutput((o) => ({\n        ...o,\n        results: response?.getResults(),\n        latency: response?.getTime(),\n        totalResults: response?.getTotalResults(),\n        error: response?.getError(),\n      }));\n    });\n  }, []);\n\n  useEffect(\n    () =>\n      variables.listen(EVENT_VALUES_UPDATED, () => {\n        searchFn();\n      }),\n    [],\n  );\n\n  return { ...searchOutput, searching };\n}\n\nfunction useNormalSearch({ queryOverride, allowEmptySearch = true }: UseSearchConfig): UseSearchResult {\n  const [error, setError] = useState<Error | null>(null);\n  const {\n    search: { searching, response, search },\n    autocomplete: { search: searchInstantFn, suggestions },\n  } = useContext();\n\n  const results = response?.getResults();\n  const searchInstant = useCallback((q: string) => searchInstantFn(q), []);\n\n  useEffect(() => {\n    if (queryOverride !== undefined) {\n      if (allowEmptySearch || queryOverride !== '') {\n        search(queryOverride);\n      }\n    } else {\n      search();\n    }\n  }, [queryOverride]);\n\n  useEffect(() => {\n    if (response) {\n      switch (true) {\n        case response.isError():\n          setError(response.getError()?.error ?? new Error('Something went wrong. Please try again.'));\n          break;\n\n        case !response.isError():\n          setError(null);\n          break;\n\n        default:\n          break;\n      }\n    }\n  }, [response]);\n\n  return {\n    latency: response?.getTime(),\n    totalResults: response?.getTotalResults(),\n    suggestions: suggestions ?? [],\n    results,\n    search,\n    searchInstant,\n    searching,\n    error,\n  };\n}\n\nfunction useSearch(params?: UseSearchParams) {\n  if (typeof params === 'object' && 'pipeline' in params && 'variables' in params) {\n    return useCustomSearch(params);\n  }\n\n  return useNormalSearch(params ?? {});\n}\n\nexport default useSearch;\nexport * from './types';\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { isNullOrUndefined } from '@sajari/react-sdk-utils';\n\nimport { useContext } from '../ContextProvider';\nimport usePagination from '../usePagination';\nimport { mapToObject } from '../utils';\n\nfunction useSearchContext() {\n  const {\n    search: { config, response, search, searching, fields = {}, clear },\n  } = useContext();\n  const { page, resultsPerPage, totalResults, pageCount, setPage } = usePagination('search');\n  const mapResponse = mapToObject(response?.getResponse() as Map<string, any> | undefined);\n  const results = response?.getResults();\n\n  return {\n    empty: response?.isEmpty() ?? false,\n    error: response?.getError(),\n    queryValues: response?.getQueryValues(),\n    latency: response?.getTime(),\n    page,\n    resultsPerPage,\n    totalResults,\n    pageCount,\n    setPage,\n    search,\n    results,\n    response: mapResponse,\n    searching,\n    searched: !isNullOrUndefined(results),\n    fields,\n    config,\n    clear,\n  };\n}\n\nexport default useSearchContext;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function mapToObject<T = Record<string, string | number>>(map: Map<string, any> | undefined): T {\n  const obj = {} as T;\n  if (map) {\n    map.forEach((v, k) => {\n      if (typeof v === 'string' || typeof v === 'number') {\n        obj[k] = v;\n      }\n    });\n  }\n\n  return obj;\n}\n","import { useCallback } from 'react';\n\nimport { useContext } from '../ContextProvider';\nimport { UseSortingResult } from './types';\n\nfunction useSorting(): UseSortingResult {\n  const {\n    search: { search, variables },\n  } = useContext();\n\n  const setSorting = useCallback(\n    (order: string) => {\n      variables.set({ sort: order });\n      search();\n    },\n    [variables, search],\n  );\n\n  return {\n    sorting: variables.get().sort ?? '',\n    setSorting,\n  };\n}\n\nexport default useSorting;\nexport * from './types';\n","import { useContext } from '../ContextProvider';\nimport { UseTrackingResult } from './types';\n\nfunction useTracking(): UseTrackingResult {\n  const {\n    resultClicked,\n    search: { pipeline },\n  } = useContext();\n  const client = pipeline.getClient();\n  return {\n    consumeInteractionToken: client.interactionConsume,\n    handleResultClicked: resultClicked,\n  };\n}\n\nexport default useTracking;\nexport * from './types';\n","import { useContext } from '../ContextProvider';\nimport { UseVariablesResult } from './types';\n\nfunction useVariables(): UseVariablesResult {\n  const {\n    search: { variables },\n  } = useContext();\n  return { variables };\n}\n\nexport default useVariables;\nexport * from './types';\n"],"names":["GoogleAnalyticsObjects","defaultConfig","qParam","qOverrideParam","qSuggestionsParam","resultsPerPageParam","pageParam","maxSuggestions","Listener","listeners","listen","callback","push","_this","unlisten","index","this","indexOf","splice","notify","fn","forEach","l","e","console","error","events","Analytics","pipeline","tracking","enabled","body","get","longestNonAutocompletedBody","longestAutocompletedBody","response","isEmpty","isError","originalBody","getQueryValues","bodyLabel","responseBody","getValues","bodyAutocompletedLabel","length","Map","Object","entries","isSSR","window","addEventListener","beforeunload","responseUpdated","resultClicked","resetBody","event","Error","url","decodeUriArgs","queryStr","args","a","split","i","hasOwnProperty","b","decodeURIComponent","encodeUriArgs","queryParts","keys","key","encodeURIComponent","join","mergeQueryStr","first","rest","arg","next","prop","augmentUri","uri","m","exec","getURLParameter","name","value","RegExp","location","search","undefined","replace","GoogleAnalytics","analytics","id","param","_this2","unregisterFunctions","sendGAPageView","onPageClose","onBodyReset","onResultClicked","isFunction","AnalyticsJS","UniversalAnalytics","GTag","pageAddress","href","substring","origin","page_location","FilterBuilder","initial","joinOperator","multi","options","array","field","group","count","isString","current","includes","set","values","merge","nonDuplicate","filter","v","emitSelectionUpdated","remove","isSet","setOptions","emitOptionsUpdated","getName","getGroup","getField","getCount","getOptions","isArray","isMulti","map","c","f","input","escaped","replaceAll","escapeValue","Boolean","getBuckets","_this3","reset","listener","RangeFilterBuilder","aggregate","min","max","step","formatter","roundToStep","range","emitEvent","emitRangeUpdated","setMin","setMax","getMinMax","getStep","isAggregate","hasChanged","format","buildArrayMatch","expressions","list","expression","groupFilters","filters","type","groups","groupBy","reduce","out","basicFilters","concat","combineFilters","removeListenerFuncs","buckets","countFilters","removeChildFilterListeners","Response","queryValues","getError","getResponse","getResults","getTotalResults","getTime","getAggregates","aggregates","getAggregateFilters","Tracking","emitTrackingReset","variables","clientTracking","getTrackingData","data","ga","Cookies","sjID","ClickTracking","InteractiveSession","DefaultSession","TrackingType","Click","NoTracking","None","PosNegTracking","PosNeg","Pipeline","config","analyticsAdapters","account","collection","endpoint","secret","p","version","client","Client","searchCount","Adapter","_emitSearchSent","_emitResponseUpdated","emitResultClicked","currentSearch","then","responseValues","clearResponse","getAnalytics","getClient","getTracking","Variables","_set","_emitUpdated","variable","Array","String","changes","updateState","query","completion","suggestions","s","slice","responseUpdatedListener","valuesUpdatedListener","createContext","strict","Provider","useContext","defaultState","priceRangePattern","patternTest","test","bind","collator","Intl","Collator","navigator","language","numeric","sortItems","sort","asc","byLabel","labelRight","valueRight","left","right","every","minLeft","Number","minRight","compare","startsWith","usePagination","context","paginate","page","parseInt","resultsPerPage","totalResults","totalPages","Math","ceil","hasNext","useMemo","hasPrevious","nextPage","useCallback","previousPage","pageCount","setPage","title","subtitle","description","image","price","originalPrice","rating","children","autocompleteProp","autocomplete","defaultFilter","searchOnLoad","initialResponse","JSON","parse","parseResponse","useState","searching","setSearching","autocompleteSearching","setAutocompleteSearching","searchState","setSearchState","autocompleteState","setAutocompleteState","configDone","setConfigDone","searchTimer","useRef","searchAutocompleteTimer","autocompleteVariables","assign","variablesFilterString","defaultFilterString","toString","searchFn","inputQuery","override","func","state","timer","text","clearTimeout","setTimeout","useEffect","mergedConfig","searchRenderTimer","prevState","clear","vals","handlePaginate","handleResultClicked","React","fields","_autocomplete$current","_autocomplete$current2","params","selected","setInternalSelected","removeListener","sortAscending","aggregateFilters","isCount","temp","label","_aggregateFilters$buc2","_aggregates$buckets","isNumber","getBucketCount","stringify","setSelected","setQuery","q","prevQuery","selectionUpdated","limit","setInternalRange","setRange","showReset","newMin","newMax","aggregateFilter","isNullOrUndefined","setResultsPerPage","size","searchOutput","setSearchOutput","o","results","latency","queryOverride","allowEmptySearch","setError","searchInstantFn","searchInstant","_response$getError","useNormalSearch","obj","mapResponse","k","empty","searched","setSorting","order","sorting","consumeInteractionToken","interactionConsume"],"mappings":"0fASO,ICFFA,EDEQC,EAAwB,CACnCC,OAAQ,IACRC,eAAgB,aAChBC,kBAAmB,gBACnBC,oBAAqB,iBACrBC,UAAW,OACXC,eAAgB,IEXLC,+BAOJC,UAAY,8BASZC,OAAA,SAAOC,0BACPF,UAAUG,KAAKD,GACb,kBAAME,EAAKC,SAASH,OAMtBG,SAAA,SAASH,OACRI,EAAQC,KAAKP,UAAUQ,QAAQN,GACjCI,GAAS,QACNN,UAAUS,OAAOH,EAAO,MAS1BI,OAAA,SAAOC,QACPX,UAAUY,SAAQ,SAACC,OAEpBF,EAAGE,GACH,MAAOC,GACHC,SAAWA,QAAQC,OACrBD,QAAQC,MAAMF,aC/BlBG,EAAS,CCP4B,uBACD,uBACI,4BDWjCC,wBAsBCC,EAAoBC,kCAgDV,WAChBhB,EAAKiB,SAAWjB,EAAKkB,OACtBlB,EAAKJ,UAAUuB,ICrFqB,wBDqFyBb,QAAO,SAACR,GACpEA,EAASE,EAAKkB,SAEhBlB,EAAKiB,SAAU,mBAOA,WACbjB,EAAKiB,UACNjB,EAAKJ,UAAUuB,IChGoB,wBDgGyBb,QAAO,SAACR,GACnEA,EAASE,EAAKkB,SAGhBlB,EAAKoB,4BAA8B,GACnCpB,EAAKqB,yBAA2B,GAChCrB,EAAKiB,SAAU,yBAOM,SAACK,OACpBA,EAASC,YAAaD,EAASE,WAInCxB,EAAKiB,SAAU,MAETQ,EAAgBH,EAASI,iBAAyCP,IAAInB,EAAK2B,YAAc,GACzFC,EAAgBN,EAASO,YAAoCV,IAAInB,EAAK8B,yBAA2BL,EAEvGzB,EAAKkB,KAAOU,EAORH,EAAaM,QAAU/B,EAAKoB,4BAA4BW,SAC1D/B,EAAKoB,4BAA8BK,EACnCzB,EAAKqB,yBAA2BO,wBAOb,WACjB5B,EAAKiB,SAAWjB,EAAKkB,OACtBlB,EAAKJ,UAAUuB,ICxIwB,4BDwIyBb,QAAO,SAACR,GACvEA,EAASE,EAAKkB,SAEhBlB,EAAKoB,4BAA8B,GACnCpB,EAAKqB,yBAA2B,GAChCrB,EAAKiB,SAAU,SA3GZA,SAAU,OACVC,KAAO,QAEPH,SAAWA,OACXC,SAAWA,OAEXpB,UAAY,IAAIoC,IACnBC,OAAOC,gBC3C8B,wBD4CJ,IAAIvC,IC3CD,wBD4CJ,IAAIA,IC3CI,4BD4CJ,IAAIA,YAKrCyB,4BAA8B,QAC9BC,yBAA2B,QAG3BM,UAAY,SACZG,uBAAyB,IAEzBK,WACHC,OAAOC,iBAAiB,eAAgBlC,KAAKmC,mBAG1CvB,SAASlB,OCrEoB,mBDqEWM,KAAKoC,sBAC7CxB,SAASlB,OCrEkB,iBDqEWM,KAAKqC,oBAC3CxB,SAASnB,OClEkB,iBDkEWM,KAAKsC,8BAS3C5C,OAAA,SAAO6C,EAAe5C,OACI,IAA3Be,EAAOT,QAAQsC,SACX,IAAIC,6BAA6BD,cAEjCvC,KAAKP,UAAUuB,IAAIuB,GAAoB7C,OAAOC,UF9E1D,SAAKX,GACHA,2BACAA,mBACAA,cAHF,CAAKA,IAAAA,OAML,IAAMyD,EAAM,CAIVC,uBAAcC,OACNC,EAAO,GACPC,EAAIF,EAASG,MAAM,SACpB,IAAMC,KAAKF,KAEVA,EAAEG,eAAeD,GAAI,KACjBE,EAAIJ,EAAEE,GAAGD,MAAM,KACrBF,EAAKM,mBAAmBD,EAAE,KAAOC,mBAAmBD,EAAE,WAGnDL,GAMTO,uBAAcP,OACNQ,EAAuB,UAC7BtB,OAAOuB,KAAKT,GAAMvC,SAAQ,SAACiD,UAAQF,EAAWxD,KAAQ2D,mBAAmBD,OAAQC,mBAAmBX,EAAKU,QAClGF,EAAWI,KAAK,MAOzBC,uBAAcC,kBACNd,EAAwB,iBAAVc,EAAqB1D,KAAK0C,cAAcgB,GAASA,qBADbC,mCAAAA,2BAExDA,EAAKtD,SAAQ,SAACuD,OACNC,EAAsB,iBAARD,EAAmB/D,EAAK6C,cAAckB,GAAOA,EACjE9B,OAAOuB,KAAKQ,GAAMxD,SAAQ,SAACyD,GACzBlB,EAAKkB,GAAQD,EAAKC,SAGf9D,KAAKmD,cAAcP,IAM5BmB,oBAAWC,EAAapB,OAChBqB,EAAI,mBAAmBC,KAAKF,UAC9BC,EACQA,EAAE,OAAMjE,KAAKyD,cAAcQ,EAAE,GAAIrB,GAEnCoB,MAAOhE,KAAKmD,cAAcP,IAMtCuB,yBAAgBC,OACRC,EAAQ,IAAIC,eAAeF,yBAA2BF,KAAKjC,OAAOsC,SAASC,SAAW,MAACC,EAAW,WAEjGvB,mBAAoBmB,EAAM,GAAcK,QAAQ,MAAO,SAAW,OAIhEC,wBAaCC,EAAsBC,EAAaC,uBAAAA,IAAAA,EAAQ,8BARX,gBAkC3B,kBAAMC,EAAKC,oBAAoB3E,SAAQ,SAACD,UAAOA,yBA2B3C,SAACW,UAAiBgE,EAAKE,eAAelE,yBAKlC,SAACA,UAAiBgE,EAAKE,eAAelE,qBAK1C,SAACA,UAAiBgE,EAAKE,eAAelE,SA9DpDiE,oBAAoBpF,KAAKgF,EAAUlF,OGjFD,uBHiFqCM,KAAKkF,mBAC5EF,oBAAoBpF,KAAKgF,EAAUlF,OGjFF,uBHiFqCM,KAAKmF,mBAC3EH,oBAAoBpF,KAAKgF,EAAUlF,OGjFE,2BHiFqCM,KAAKoF,uBAe7EP,GAbF7C,UAaO,UAZCyC,IAAPI,EACQA,EACDQ,aAAWpD,OAAOjD,EAAuBsG,cACxCtG,EAAuBsG,YACxBD,aAAWpD,OAAOjD,EAAuBuG,qBACxCvG,EAAuBuG,mBACxBF,aAAWpD,OAAOjD,EAAuBwG,OACxCxG,EAAuBwG,KAEvB,UAKTV,MAAQA,qBAWRG,eAAA,SAAelE,MAChBf,KAAK6E,KAAO7C,WAAWqD,aAAWpD,OAAOjC,KAAK6E,KAAM,OAEhDY,EAAchD,EAAIsB,WAEtB9B,OAAOsC,SAASmB,KAAKC,UAAU1D,OAAOsC,SAASqB,OAAOhE,gBACnD5B,KAAK8E,OAAQ/D,MAGdf,KAAK6E,KAAO7F,EAAuBwG,KACrCvD,OAAOjC,KAAK6E,IAAI,QAAS,YAAa,CACpCgB,cAAeJ,IAGjBxD,OAAOjC,KAAK6E,IAAI,OAAQ,WAAYY,UIlHtC/E,EAAS,CDPwB,oBACF,mBCWhBoF,qCA8BjBC,QAAAA,aAAU,SACVC,aAAAA,aAAe,WACfC,MAAAA,oBACAC,QAAAA,aAAU,SACVC,MAAAA,gBACA/B,IAAAA,KACAgC,IAAAA,MACAC,IAAAA,UACAC,MAAAA,aAAQlF,UAAQ8E,KAEZK,WAASR,KACXA,EAAU,CAACA,SAIRS,QAAUT,OAEVA,QAAUA,OAEV3B,KAAOA,OAEPiC,MAAQA,OAERD,MAAQA,OAERE,MAAQA,OAERJ,QAAUA,OAEVD,MAAQA,OAERE,MAAQA,OAERH,aAAeA,OAEfvG,kBD7E8B,qBC8EN,IAAID,ID7EA,mBC8EN,IAAIA,gCAO1BE,OAAA,SAAO6C,EAAe5C,OACtBe,EAAO+F,SAASlE,SACb,IAAIC,6BAA6BD,cAElCvC,KAAKP,UAAU8C,GAAO7C,OAAOC,MAM/B+G,IAAA,SAAIC,EAAkBC,0BAAAA,IAAAA,GAAQ,GAC/BA,EAAO,KACHC,EAAeF,EAAOG,QAAO,SAACC,UAAOlH,EAAK2G,QAAQC,SAASM,WAC5DP,kBAAcxG,KAAKwG,QAAYK,aAE/BL,QAAUG,OAGZK,0BAMAC,OAAA,SAAON,QACPH,QAAUxG,KAAKwG,QAAQM,QAAO,SAACC,UAAOJ,EAAOF,SAASM,WACtDC,0BAMAE,MAAA,SAAM9C,UACJpE,KAAKwG,QAAQC,SAASrC,MAMxB+C,WAAA,SAAWjB,EAAkBU,YAAAA,IAAAA,GAAQ,QAEnCV,QADHU,OACkB5G,KAAKkG,QAAYA,GAEtBA,OAGZkB,wBAGAC,QAAA,kBACErH,KAAKoE,QAGPkD,SAAA,kBACEtH,KAAKqG,SAGPkB,SAAA,kBACEvH,KAAKoG,SAGPoB,SAAA,kBACExH,KAAKsG,SAGPmB,WAAA,kBACEzH,KAAKkG,WAGPlF,IAAA,kBACEhB,KAAKwG,WAGPkB,QAAA,kBACE1H,KAAKmG,SAGPwB,QAAA,kBACE3H,KAAKiG,SAMPa,OAAA,sBACCZ,EAAUlG,KAAKwG,QAClBoB,KAAI,SAACC,OACAC,EAAI/C,EAAKmB,QAAQ2B,UACjBxC,aAAWyC,KACbA,EAAIA,KAED1G,UAAQ0G,KACXA,EAtLU,SAACC,YAAAA,IAAAA,EAAQ,QACvBC,EAAUD,QACA,CAAC,KAET1H,SAAQ,SAACwH,GACbG,EAAUC,aAAWF,EAAOF,OAAQA,MAG/BG,EA8KKE,CAAYJ,IAEd/C,EAAKuB,YAAe7B,IAANqD,GAAmBD,IACnCC,EAAI/C,EAAKoB,MAAWpB,EAAKqB,cAAayB,OAAW9C,EAAKqB,aAAYyB,OAE7DC,KAERhB,OAAOqB,gBAENjC,EAAQtE,OAAS,EACZsE,EAAQ1C,KAAK,IAGf0C,EAAQ0B,KAAI,SAACE,aAAUA,SAAMtE,SAASxD,KAAKgG,qBAG7CoC,WAAA,6BACEtG,OAAOC,QAAQ/B,KAAKkG,SACxB0B,KAAI,mBAAqBS,EAAKjE,0BAC9BZ,KAAK,QAMH8E,MAAA,gBACA9B,kBAAcxG,KAAK+F,cACnBiB,0BAOGA,qBAAA,gBACHvH,UDrN8B,qBCqNKU,QAAO,SAACoI,GAC9CA,UAQMnB,mBAAA,gBACH3H,UD9N4B,mBC8NKU,QAAO,SAACoI,GAC5CA,aCtOA7H,EAAS,CFSoB,iBEPd8H,iCAwBjBpC,IAAAA,MACAhC,IAAAA,KACAiC,IAAAA,UACAoC,UAAAA,gBACA1C,IAAAA,YACA2C,IAAAA,aAAM,QACNC,IAAAA,aAAMF,EAAY,EAAI,UACtBG,KAAAA,aAAO,QACPC,UAAAA,aAAY,SAACxE,UAAiBA,EAAMuD,KAAI,SAACb,UAAM+B,cAAY/B,EAAG6B,cAGvD7C,aADgB,IAAZA,EACM0C,EAAY,KAAO,CAACC,EAAKC,GAEzB5C,OAGZgD,MAAQ/I,KAAK+F,aACb3B,KAAOA,OACPiC,MAAQA,OACRD,MAAQA,OACRyC,UAAYA,OACZH,IAAMA,OACNC,IAAMA,OACNC,KAAOA,OACPH,UAAYA,OACZhJ,kBF1C0B,iBE2CN,IAAID,gCAOxBE,OAAA,SAAO6C,EAAe5C,OACtBe,EAAO+F,SAASlE,SACb,IAAIC,6BAA6BD,cAGlCvC,KAAKP,UAAU8C,GAAO7C,OAAOC,MAG/BqB,IAAA,kBACEhB,KAAK+I,SAGPrC,IAAA,SAAIqC,EAAqBC,YAAAA,IAAAA,GAAY,QACrCD,MAAQA,EAAQ/I,KAAK6I,UAAUE,GAASA,EAEzCC,QACGC,sBAIF5B,QAAA,kBACErH,KAAKoE,QAGPkD,SAAA,kBACEtH,KAAKqG,SAGPkB,SAAA,kBACEvH,KAAKoG,SAGP8C,OAAA,SAAO7E,QACPqE,IAAMrE,KAGN8E,OAAA,SAAO9E,QACPsE,IAAMtE,KAGN+E,UAAA,iBACE,CAACpJ,KAAK0I,IAAK1I,KAAK2I,QAGlBU,QAAA,kBACErJ,KAAK4I,QAMP9B,OAAA,kBACA9G,KAAK+I,MAIA/I,KAAKoG,aAAYpG,KAAK+I,MAAM,WAAU/I,KAAKoG,aAAYpG,KAAK+I,MAAM,GAHnE,MAMJO,YAAA,kBACEtJ,KAAKyI,aAMPc,WAAA,kBACAvJ,KAAK+I,OAAU/I,KAAK+F,QAIlB/F,KAAK+I,MAAM,KAAO/I,KAAK+F,QAAQ,IAAM/F,KAAK+I,MAAM,KAAO/I,KAAK+F,QAAQ,GAHlE/F,KAAK+I,QAAU/I,KAAK+F,WASxBuC,MAAA,SAAMU,YAAAA,IAAAA,GAAY,QAClBD,MAAQrB,UAAQ1H,KAAK+F,mBAAe/F,KAAK+F,SAAW/F,KAAK+F,QAE1DiD,QACGC,sBAIFO,OAAA,SAAOnF,UACLrE,KAAK6I,UAAUxE,MAOd4E,iBAAA,2BACHxJ,UFhJ0B,iBEgJKU,QAAO,SAACoI,GAC1CA,EAAS1I,YCxJT4J,EAAkB,SAACC,OACnBC,EAAOD,EAAY5C,OAAOqB,gBAE1BwB,EAAK/H,OAAS,IAChB+H,EAAOA,EAAK/B,KAAI,SAACgC,aAAmBA,yBAGhBD,EAAKnG,KAAK,cAIlC,SAAgBqG,EACdC,EACAC,EACA/D,OAEI2D,EAAOG,EAAQlC,KAAI,SAACE,SAAO,CAC7BzB,MAAOyB,EAAER,WACTlB,MAAO0B,EAAEP,WACTqC,WAAY9B,EAAEhB,SACdR,MAAOwB,aAAahC,GAAiBgC,EAAEN,eAI5B,WAATuC,IACFJ,EAAOA,EAAK7C,QAAO,mBAAoBqB,UAAjByB,oBAIlBI,EAASlI,OAAOC,QAAQkI,UAAQN,EAAM,UACzC7C,QAAO,mBAAaqB,iBACpB+B,QACC,SAACC,uBACIA,qBACMvC,KAAI,qBAAGgC,oBAElB,OAIS,WAATG,EAAmB,OAEfK,EAAeT,EAAK7C,QAAO,qBAAGT,UAAOC,SAA8BsB,KAAI,wBAAGgC,2BAEzE9H,OAAOC,QAAQiI,GACnBE,QAAO,SAACC,SAAaT,aACN,oBAAgBtI,UAAQsI,GAI/BS,YAHMA,GAAKV,EAAgBC,OAIjC,KACFW,eAAUD,GACV5G,KAAKwC,UAIH2D,EACJ7C,QAAO,gBAAUR,IAAAA,aAAalF,YAApBgF,QAAsCE,KAChDsB,KAAI,gBAAGvB,IAAAA,MAAOuD,IAAAA,WAAYtD,IAAAA,aACrBD,IAAUjF,UAAQ4I,EAAO3D,IACpBoD,EAAgBO,EAAO3D,IAGzBC,EAAQsD,EAAa,QAE7B9C,QAAO,SAACvG,UAAY,OAANA,KACdiD,KAAKwC,OCpEJtF,EAAS,CJKwB,oBACF,kBAEF,0BIKX4J,EACtBR,EACA9D,kBAAAA,IAAAA,EAA6B,WAEvBvG,UJZ+B,qBIaR,IAAID,IJZE,mBIaR,IAAIA,IJXE,iBIYR,IAAIA,KAEvB+K,EAAsC,UAS5CT,EAAQzJ,SAAQ,SAACyH,GACXA,aAAahC,GACfyE,EAAoB3K,KAClBkI,EAAEpI,OJ7B6B,qBI6BG,WAChCD,EJ9B6B,qBI8BMU,QAAO,SAACoI,GACzCA,EAAST,SAGbA,EAAEpI,OJjC2B,mBIiCG,WAC9BD,EJlC2B,mBIkCMU,QAAO,SAACoI,GACvCA,EAAST,UAKbA,aAAaU,GACf+B,EAAoB3K,KAClBkI,EAAEpI,OJxCyB,iBIwCG,WAC5BD,EJzCyB,iBIyCMU,QAAO,SAACoI,GACrCA,EAAST,aA+CZ,CAAEhB,OAnCM,kBAAM+C,EAAaC,EAAS,aAAc9D,QAmCxCtG,gBAzED6C,EAAe5C,OACE,IAA3Be,EAAOT,QAAQsC,SACX,IAAIC,6BAA6BD,cAElC9C,EAAU8C,GAAO7C,OAAOC,IAqER6K,QAhCT,kBACdV,EACGhD,QAAO,SAACgB,UAAMA,aAAahC,IAAkBgC,EAAEN,cAC/CI,KAAI,SAACE,UAAMA,aAAahC,GAAiBgC,EAAEM,gBAC3CtB,OAAOqB,SACP3E,KAAK,MA2BwBiH,aAxBb,kBAAMZ,EAAaC,EAAS,eAAgB,MAwBjBxD,MArBlC,kBACZwD,EACGhD,QAAO,SAACgB,UAAMA,aAAahC,GAAiBgC,EAAEN,cAC9CI,KAAI,SAACE,UAAMA,aAAahC,GAAiBgC,EAAEP,cAC3CT,OAAOqB,SACP3E,KAAK,MAgB6CkH,sCAvCrDH,EAAoBlK,SAAQ,SAACD,UAAOA,QAuC6CuI,IANvE,kBACVmB,EACGhD,QAAO,SAACgB,UAAMA,aAAaU,GAAsBV,EAAEwB,iBACnD1B,KAAI,SAACE,UAAMA,EAAEP,cACb/D,KAAK,MAE8EkF,IAb5E,kBACVoB,EACGhD,QAAO,SAACgB,UAAMA,aAAaU,GAAsBV,EAAEwB,iBACnD1B,KAAI,SAACE,UAAMA,EAAEP,cACb/D,KAAK,WC3FCmH,wBAiBTlK,EACAmK,EACAzJ,EACAwF,QAEKlG,MAAQA,OACRmK,YAAcA,OACdzJ,SAAWA,OACXwF,OAASA,6BAMTvF,QAAA,kBAEY,OAAfpB,KAAKS,YAAoCgE,IAAlBzE,KAAKmB,eAA0CsD,IAAhBzE,KAAK2G,aAA6ClC,IAArBzE,KAAK4K,eAOrFvJ,QAAA,kBACiB,OAAfrB,KAAKS,SAMPoK,SAAA,kBACE7K,KAAKS,SAMPc,eAAA,kBACEvB,KAAK4K,eAMPE,YAAA,kBACE9K,KAAKmB,YAMPO,UAAA,kBACE1B,KAAK2G,UAMPoE,WAAA,uBACoBtG,IAAlBzE,KAAKmB,SAA0BnB,KAAKmB,SAASH,IAAI,gBAA0ByD,KAM7EuG,gBAAA,uBACoBvG,IAAlBzE,KAAKmB,SAA0BnB,KAAKmB,SAASH,IAAI,qBAA6ByD,KAMhFwG,QAAA,uBACoBxG,IAAlBzE,KAAKmB,SAA0BnB,KAAKmB,SAASH,IAAI,aAAqByD,KAMxEyG,cAAA,mBACiBzG,IAAlBzE,KAAKmB,cAIHgK,EAAanL,KAAKmB,SAASH,IAAI,sBAClByD,IAAf0G,SAGGA,MAMFC,oBAAA,mBACiB3G,IAAlBzE,KAAKmB,cAIHgK,EAAanL,KAAKmB,SAASH,IAAI,4BAClByD,IAAf0G,SAGGA,SCpHLzK,EAAS,CNFqB,kBMMvB2K,oDAC6B,UAOjC5L,UAAY,IAAIoC,IACnBC,OAAOC,gBNfuB,kBMgBJ,IAAIvC,kCAW3BE,OAAA,SAAO6C,EAAe5C,OACI,IAA3Be,EAAOT,QAAQsC,SACX,IAAIC,6BAA6BD,cAEjCvC,KAAKP,UAAUuB,IAAIuB,GAAoB7C,OAAOC,MAMhD2L,kBAAA,SAAkB3E,QAClBlH,UAAUuB,INtCgB,kBMsCuBb,QAAO,SAACoI,GAC7DA,EAAS5B,SAQN2B,MAAA,SAAMiD,QACLC,eAA2BlD,aAEf7D,IAAd8G,QAEGD,kBAAkBC,MAQpB1H,KAAA,SAAK0H,MACkB,OAAxBvL,KAAKwL,qBACD,IAAIhJ,MAAM,iCAGXxC,KAAKwL,eAAe3H,KAAK0H,SCrEvBE,EAAkB,eACvBC,EAAO,GACPC,EAAKC,EAAQ5K,IAAI,OACnB2K,IACFD,EAAKC,GAAKA,OAENE,EAAOD,EAAQ5K,IAAI,eACrB6K,IACFH,EAAKG,KAAOA,GAEPH,GCPII,yBAMC1F,EAAelH,yBAAfkH,IAAAA,EAAQ,gBAAOlH,IAAAA,EAAS,4BAG7BkH,MAAQA,IACRoF,eAAiB,IAAIO,qBACxB7M,EACA,IAAI8M,iBAAeC,eAAaC,MAAOrM,EAAKuG,MAAOqF,yBAZtBJ,GCAtBc,8DAOJ/F,MAAQ,QACRoF,eAAiB,IAAIQ,iBAAeC,eAAaG,KAAMvM,EAAKuG,MAAOqF,wBAR5CJ,GCAnBgB,yBAKCjG,yBAAAA,IAAAA,EAAQ,8BAGbA,MAAQA,IACRoF,eAAiB,IAAIQ,iBAAeC,eAAaK,OAAQzM,EAAKuG,MAAOqF,wBAT1CJ,GCK9B3K,EAAS,CXVkB,cACK,mBACF,kBWYvB6L,wBA+BTC,EAOApI,EACAvD,EACA4L,uBADA5L,IAAAA,EAAwD,IAAIsL,YAC5DM,IAAAA,EAAoB,CAAC9H,kBArBM,IAAIgG,EAAS,UAuBhC+B,EAA+CF,EAA/CE,QAASC,EAAsCH,EAAtCG,WAAYC,EAA0BJ,EAA1BI,SAAUtJ,EAAgBkJ,EAAhBlJ,IAAKuJ,EAAWL,EAAXK,YACvCL,OAASA,MAERM,EAAyC,CAC7C1I,UAAMK,EACNsI,aAAStI,GAEP8B,WAASnC,GACX0I,EAAE1I,KAAOA,EACA,SAAUA,IACnB0I,EAAE1I,KAAOA,EAAKA,KACd0I,EAAEC,QAAU3I,EAAK2I,cAKZC,OADHhL,UACY,IAAIiL,SAAOP,EAASC,EAAYC,EAAUtJ,EAAKuJ,GAE/C,IAAII,SAAOP,EAASC,EAAYC,QAG3ChM,SAAWZ,KAAKgN,OAAOpM,SAASkM,EAAE1I,KAAgB0I,EAAEC,cACpDlM,SAAWA,OACXpB,UAAY,IAAIoC,IAAI,CACvB,CXhF2B,cWgFP,IAAIrC,GACxB,CXhFgC,mBWgFP,IAAIA,GAC7B,CXhF8B,iBWgFP,IAAIA,UAExB0N,YAAc,OACd/L,SAAW,IAAIwJ,EAAS,WAExB/F,UAAY,IAAIjE,EAAUX,KAAMA,KAAKa,UAC1C4L,EAAkBpM,SAAQ,SAAC8M,OAErBA,EAAQtN,EAAK+E,yCAUdlF,OAAA,SAAO6C,EAAe5C,OACI,IAA3Be,EAAOT,QAAQsC,SACX,IAAIC,6BAA6BD,cAEjCvC,KAAKP,UAAUuB,IAAIuB,GAAoB7C,OAAOC,MAOjDyN,gBAAA,SAAgB7B,QACf9L,UAAUuB,IXhHa,eWgHuBb,QAAO,SAACoI,GAC1DA,EAASgD,SAQN8B,qBAAA,SAAqBlM,QACpB1B,UAAUuB,IXzHkB,oBWyHuBb,QAAO,SAACoI,GAC/DA,EAASpH,SAQNmM,kBAAA,SAAkBjJ,QACjB5E,UAAUuB,IXlIgB,kBWkIuBb,QAAO,SAACoI,GAC7DA,EAASlE,SAQNG,OAAA,SAAO+G,mBACP2B,aAAe,MACdK,EAAgBvN,KAAKkN,iBAEtBtM,SACF4D,OAAO+G,EAAWvL,KAAKa,SAASgD,KAAK0H,IACrCiC,MAAK,gBAAErM,OAAUsM,OACZF,EAAgBxI,EAAKmI,cAIzBnI,EAAK5D,SAAW,IAAIwJ,EAClB,KACA,IAAI9I,IAAIC,OAAOC,QAAQwJ,IACvB,IAAI1J,IAAIC,OAAOC,QAAQZ,IACvB,IAAIU,IAAIC,OAAOC,QAAQ0L,gBAGpB,SAAChN,GAGND,QAAQC,MAAMA,GAEV8M,EAAgBxI,EAAKmI,cAIzBnI,EAAK5D,SAAW,IAAIwJ,EAASlK,EAAO,IAAIoB,IAAIC,OAAOC,QAAQwJ,SAAa9G,OAAWA,gBAE5E,WACPM,EAAKsI,qBAAqBtI,EAAK5D,kBAE9BiM,gBAAgB7B,MAOhBmC,cAAA,SAAcnC,QACd1K,SAASgD,KAAK0H,QACd2B,aAAe,OACf/L,SAAW,IAAIwJ,EAAS,WACxB0C,qBAAqBrN,KAAKmB,aAM1B2J,YAAA,kBACE9K,KAAKmB,YAMPwM,aAAA,kBACE3N,KAAK4E,aAMPgJ,UAAA,kBACE5N,KAAKgN,UAMPa,YAAA,kBACE7N,KAAKa,eCxMHiN,wBASCvC,kBAAAA,IAAAA,EAAgF,SACrF9L,UAAY,IAAIoC,IAAI,CAAC,CZlBM,iBYkBiB,IAAIrC,UAChD+L,UAAY,IAAI1J,IACnBC,OAAOC,kBACJ9C,EAAcC,QAAS,KACvBD,EAAcI,qBAAsB,MAClCkM,gCAUF7L,OAAA,SAAO6C,EAAe5C,MZjCK,mBYkC5B4C,QACI,IAAIC,6BAA6BD,cAEjCvC,KAAKP,UAAUuB,IAAIuB,GAAoB7C,OAAOC,MAQjD+G,IAAA,SAAI6E,QACJwC,KAAKxC,QACLyC,aAAazC,MAMbvK,IAAA,eACCuK,EAAY,eAEbA,UAAUlL,SAAQ,SAAC4N,EAAU3K,GAE9BiI,EAAUjI,GADY,mBAAb2K,EACQA,IACRC,MAAMxG,QAAQuG,GACNA,EAASzK,KAAK,KAEd2K,OAAOF,MAGrB1C,KAQDyC,aAAA,SAAaI,mBACb3O,UAAUuB,IZ1EgB,kBY0EuBb,QAAO,SAACoI,UAC7DA,EAAS6F,GAAS,SAAC7C,UAA+B1L,EAAKkO,KAAKxC,YAOxDwC,KAAA,SAAKxC,cACXzJ,OAAOuB,KAAKkI,GAAWlL,SAAQ,SAACiD,QACPmB,IAAnB8G,EAAUjI,GACZyB,EAAKwG,iBAAiBjI,GAEtByB,EAAKwG,UAAU7E,IAAIpD,EAAKiI,EAAUjI,aC7DpC+K,EAAc,SAACC,EAAeb,EAAiDjB,OAC7E+B,EAAaD,GAASb,GAAiBA,EAAezM,IAAIwL,EAAOtN,SAAgB,GACnFsP,EAAwB,UACxBf,IACFe,GAAef,EAAezM,IAAIwL,EAAOpN,oBAAsB,IAC5D0D,MAAM,KACNgE,QAAO,SAAC2H,UAAMA,EAAE7M,OAAS,KACzB8M,MAAM,EAAGlC,EAAOjN,iBAGd,CACLgP,WAAAA,EACAD,MAAAA,EACAE,YAAAA,IAIEG,EAA0B,SAACpD,EAAsBiB,EAAgBrL,OAC/DmN,EAAQ/C,EAAUvK,MAAMwL,EAAOtN,SAAW,GAC1CuO,EAAiBtM,EAASO,mBAEzB2M,EAAYC,EAAOb,EAAgBjB,IAGtCoC,EAAwB,SAACrD,EAAsB3K,EAAoB4L,OACjE8B,EAAQ/C,EAAUvK,MAAMwL,EAAOtN,SAAW,GAC1CuO,EAAiB7M,EAASkK,cAAcpJ,mBAEvC2M,EAAYC,EAAOb,EAAgBjB,MAGbqC,gBAAuB,CACpDC,QAAQ,EACR1K,KAAM,oBAFD2K,OAAUC,OAKXC,EAAsC,CAC1C9N,SAAU,KACVmN,MAAO,GACPC,WAAY,GACZC,YAAa,GACbhC,OAAQvN,GCnEJiQ,EAAoB,gBACpBC,EAAcD,EAAkBE,KAAKC,KAAKH,GAC1CI,EAAW,IAAIC,KAAKC,SAAUxN,UAAsC,QAA5BC,OAAOwN,UAAUC,SAAoB,CACjFC,SAAS,IAMEC,EAAY,SAACjG,EAAckG,EAA0BC,eAA1BD,IAAAA,EAAiB,kBAASC,IAAAA,GAAM,GACzD,SAATD,SACKlG,MAGHoG,EAAmB,UAATF,QAET,UAAIlG,GAAMkG,MAAK,kBAA0BG,OAAYC,OACpDC,EAAO/B,OAAO4B,aACdI,EAAQhC,OAAO4B,EAAUC,EAAaC,WAEpC,OACD,CAACC,EAAMC,GAAOC,MAAMjB,OACjBkB,EAAUH,EAAKpN,MAAM,OAAO8E,IAAI0I,QAAQ,GACxCC,EAAWJ,EAAMrN,MAAM,OAAO8E,IAAI0I,QAAQ,UAC5CR,EACKR,EAASkB,QAAQrC,OAAOkC,GAAUlC,OAAOoC,IAE3CjB,EAASkB,QAAQrC,OAAOoC,GAAWpC,OAAOkC,SAE9CH,EAAKO,WAAW,UAChBN,EAAMM,WAAW,YACbX,EAAM,GAAK,OACfI,EAAKO,WAAW,UAChBN,EAAMM,WAAW,YACbX,GAAO,EAAI,SAKlBA,EACKR,EAASkB,QAAQrC,OAAO+B,GAAO/B,OAAOgC,IAExCb,EAASkB,QAAQrC,OAAOgC,GAAQhC,OAAO+B,QCzClD,SAASQ,EAAcpN,YAAAA,IAAAA,EAAiC,cAChDqN,EAAU3B,IACR4B,EAAaD,EAAbC,WACqBD,EAAQrN,GAA7BnC,IAAAA,SAAUqL,IAAAA,OACZ5B,QAAczJ,SAAAA,EAAUI,iBACxBsP,SAAOjG,SAAAA,EAAa5J,IAAIwL,EAAOlN,YAAawR,SAASlG,EAAY5J,IAAIwL,EAAOlN,WAAsB,IAAM,EACxGyR,SAAiBnG,SAAAA,EAAa5J,IAAIwL,EAAOnN,sBAC3CyR,eAASlG,SAAAA,EAAa5J,IAAIwL,EAAOnN,qBAAgC,IACjE,GACE2R,SAAe7P,SAAAA,EAAU6J,oBAAqB,EAC9CiG,EAAaC,KAAKC,KAAKH,EAAeD,GACtCK,EAAUC,WAAQ,kBAAMR,EAAOI,IAAY,CAACJ,EAAMI,IAClDK,EAAcD,WAAQ,kBAAMR,EAAO,IAAG,CAACA,IACvCU,EAAWC,eAAY,kBAAMJ,GAAWR,EAASC,EAAO,KAAI,CAACD,EAAUQ,IACvEK,EAAeD,eAAY,kBAAMF,GAAeV,EAASC,EAAO,KAAI,CAACD,EAAUU,UAE9E,CACLT,KAAAA,EACAa,UAAWT,EACXD,aAAAA,EACAW,QAASf,EACTG,eAAAA,EACAK,QAAAA,EACAE,YAAAA,EACAC,SAAAA,EACAE,aAAAA,8DfrBsC,2DADC,8DAEG,yDAGT,8CAEF,+CAdG,gDACF,2CAFH,8CAYM,iDANH,8CAFA,yCgB8ElC,SAAY1J,eAWNA,EAAAA,EAAS,OATXlD,OACApC,IAAAA,aAAM,YACNmP,MAAAA,aAAQ,cACRC,SAAAA,aAAW,YACXC,YAAAA,aAAc,oBACdC,MAAAA,aAAQ,cACRC,MAAAA,aAAQ,cACRC,cAAAA,aAAgB,sBAChBC,OAAAA,aAAS,gBAGNrN,cAXE,aAYFpC,IAAMA,OACNmP,MAAQA,OACRC,SAAWA,OACXC,YAAcA,OACdC,MAAQA,OACRC,MAAQA,OACRC,cAAgBA,OAChBC,OAASA,8IHbsC,oBACtDC,IAAAA,SACA3N,IAAAA,OACc4N,IAAdC,aACAC,IAAAA,cACAC,IAAAA,aAGMC,EAvBc,SAACA,OAChBjM,WAASiM,IAAoBpR,UAAQoR,UACjC,WAGgDC,KAAKC,MAAMF,OAA5D5H,gBAAkBzJ,SAAAA,aAAW,SAAIwF,OAAAA,aAAS,YAE3C,IAAIgE,EACT,KACA,IAAI9I,IAAIC,OAAOC,mBAJK,OAKpB,IAAIF,IAAIC,OAAOC,QAAQZ,IACvB,IAAIU,IAAIC,OAAOC,QAAQ4E,KAYDgM,GAFxBH,mBAGkCI,YAAS,GAApCC,OAAWC,SACwCF,YAAS,GAA5DG,OAAuBC,SACQJ,gBAAc3D,GAAc9N,SAAUqR,KAArES,OAAaC,SAC8BN,WAAS3D,GAApDkE,OAAmBC,SACUR,YAAS,GAAtCS,OAAYC,OACbC,EAAcC,WACdC,EAA0BD,WAC1BnB,EAAemB,SAAOpB,GACtB7G,EAAYiI,kBAAOhP,EAAO+G,aAAa,IAAIuC,GAC3C4F,EAAwBF,wBAAOpB,SAAAA,EAAkB7G,aAAa,IAAIuC,GAEpE3M,EAAWqD,EAAO5D,SAASkK,iBAC3B3J,EAASC,WAAiC,OAApBoR,IACxBrR,EAAWqR,GAGRhO,EAAO+G,WAAc8H,GAExBvR,OAAO6R,OAAOnP,EAAQ,CAAE+G,UAAWA,EAAU/E,WAE3C4L,GAAqBA,EAAiB7G,WAAc8H,GAEtDvR,OAAO6R,OAAOvB,EAAkB,CAAE7G,UAAWmI,EAAsBlN,WAGhE6M,EAAY,WACTvM,EAASwD,WAAe9F,EAAOsF,WAAW,IAC1C8J,WAAwBrI,EAAU/E,QAAQxF,MAAM8F,UAAU,GAC1D+M,iBAAsBvB,SAAAA,EAAewB,cAAc,GAEzDvI,EAAU/E,QAAQE,IAAI,CACpBI,OAAQ,eACA8C,EAAa9C,EAAOA,eACnB,CAAC+M,EAAqBD,EAAuBxS,UAAQwI,GAAc,YAAcA,GACrF9C,OAAOqB,SACP3E,KAAK,UAEViH,aAAc,kBAAM3D,EAAO2D,gBAC3BD,QAAS,kBAAM1D,EAAO0D,WACtBlE,MAAO,kBAAMQ,EAAOR,SACpBoC,IAAK,kBAAM5B,EAAO4B,OAClBC,IAAK,kBAAM7B,EAAO6B,aAIhBoL,EAAWvC,eACf,SAAClO,UAAmC,SAAC0Q,EAAqBC,kBAAAA,IAAAA,GAAW,OAC7DC,EAAe,iBAAR5Q,EAAyB+O,EAAa7L,QAAUhC,EACvD2P,EAAgB,iBAAR7Q,EAAyB6P,EAAoBF,EAErDmB,EAAgB,iBAAR9Q,EAAyBmQ,EAA0BF,GAD/B,iBAARjQ,EAAyB0P,EAA2BF,IAE5D,GAClBI,GAAe,SAACiB,eAAgBA,GAAO7F,YAAO0F,EAAAA,EAAcG,EAAM7F,eAC1D1N,EAAwBsT,EAAxBtT,SAAU2K,EAAc2I,EAAd3I,UACViB,EAAW2H,EAAX3H,OAEF6H,UACH7H,EAAOtN,cAAS8U,EAAAA,EAAczI,EAAUvK,MAAMwL,EAAOtN,UACrDsN,EAAOrN,qBAAiBsF,IACxB+H,EAAOlN,gBAAYmF,KAIlBwP,IACFI,EAAK7H,EAAOrN,gBAAkB,QAGhCoM,EAAU7E,IAAI2N,GAEVD,EAAM5N,SACR8N,aAAaF,EAAM5N,SAGrB4N,EAAM5N,QAAU+N,YAAW,WACzB3T,EAAS4D,OAAO+G,EAAUvK,SACzB,OAEL,IAGFwT,aAAU,eACFC,OAAoBxV,EAAkBuF,EAAOgI,QAEnD0G,GAAe,SAACiB,eACXA,GACHhT,SAAAA,EACAmN,MAAO/C,EAAU/E,QAAQxF,MAAMyT,EAAavV,SAAW,GACvDsN,OAAQiI,OAGVrB,GAAqB,SAACe,eACjBA,GACH3H,YAAavN,EAAkBuF,EAAOgI,iBAepCkI,EAZE1P,EAAoC,MAEtCR,EAAOsF,QAAS,KACZhD,EAASwD,EAAe9F,EAAOsF,SAErC9E,EAAoBpF,KAClBkH,EAAOpH,Ob5LwB,qBa4LQ,kBAAMqU,EAAS,SAATA,MAC7CjN,EAAOpH,Ob1LoB,iBa0LQ,kBAAMqU,EAAS,SAATA,MACzCjN,EAAO4D,+BAMX1F,EAAoBpF,KAClB4E,EAAO5D,SAASlB,ObhNgB,oBagNe,SAACyB,SAC9CmT,aAAaI,GAEbA,EAAoBH,YAClB,WACEzB,GAAa,GACbI,GAAe,SAACyB,eACXA,GACHxT,SAAAA,GACGwN,EAAwBpD,EAAU/E,QAASmO,EAAUnI,OAAQrL,SAIlC,cAAlCA,EAAS4J,uBAAcnJ,QAAe,IAAM,QAKlDoD,EAAoBpF,KAClB2L,EAAU/E,QAAQ9G,ObhOY,kBagOiB,kBAC7CwT,GAAe,SAACyB,eACXA,EACA/F,EAAsBrD,EAAU/E,QAAShC,EAAO5D,SAAU+T,EAAUnI,iBAKxE6F,EAAa7L,QAAS,OACiBhC,EAAO5D,SAAS4L,OAC1D6F,EAAa7L,QAAU,CACrB5F,SAAU,IAAI2L,EAAS,CAAEG,UAFnBA,QAE4BC,aAFnBA,WAE+BC,WAFnBA,UAE+B,gBAC1DrB,UAAWmI,EAAsBlN,gBAIrCxB,EAAoBpF,KAClByS,EAAa7L,QAAQ5F,SAASlB,ObpPE,oBaoP6B,SAACyB,GAC5D6R,GAAyB,GACzBI,GAAqB,SAACuB,eACjBA,GACHxT,SAAAA,GACGwN,EAAwB+E,EAAsBlN,QAASmO,EAAUnI,OAAQrL,WAKlF6D,EAAoBpF,KAClB8T,EAAsBlN,QAAQ9G,Ob5PA,kBa4P6B,kBACzD0T,GAAqB,SAACuB,eACjBA,EACA/F,EACD8E,EAAsBlN,QACrB6L,EAAa7L,QAAmC5F,SACjD+T,EAAUnI,gBAMd+F,GACF/N,EAAO5D,SAAS4D,OAAO+G,EAAU/E,QAAQxF,OAG3CsS,GAAc,GAEP,WACLtO,EAAoB3E,SAAQ,SAACD,UAAOA,UAErC,QA4BiB+T,MA1BdS,EAAQpD,eACZ,SAAClO,UAAmC,SAACuR,OAC7BX,EAAe,iBAAR5Q,EAAyB+O,EAAa7L,QAAUhC,EACrD5D,EAAwBsT,EAAxBtT,SAAU2K,EAAc2I,EAAd3I,eAEL9G,IAAToQ,GACFtJ,EAAU7E,IAAImO,GAEhBjU,EAAS8M,cAAcnC,EAAUvK,UAEnC,IAGI8T,GAAiBtD,eACrB,SAACX,SACSjQ,EAAwB4D,EAAxB5D,SAAU2K,EAAc/G,EAAd+G,UAGlBA,EAAU7E,YAFSuM,EAAXzG,OAEgBlN,WAAY6O,OAAO0C,OAC3CjQ,EAAS4D,OAAO+G,EAAUvK,SAE5B,CAACwD,EAAO5D,SAAU4D,EAAO+G,UAAW0H,EAAYzG,SAG5CuI,GAAsBvD,eAAY,SAAC/O,UAAgB+B,EAAO5D,SAAS0M,kBAAkB7K,KAAM,WA6B1FuS,gBAACjG,GAAS1K,OA3BG8P,EA2Be,CAAE9B,aAAcc,EAAmB3O,OAAQyO,QAzBvEkB,GACH3P,YACK2P,EAAM3P,QACT+G,UAAWA,EAAU/E,QACrBsD,QAAStF,EAAOsF,QAChBlJ,SAAU4D,EAAO5D,SACjB4D,OAAQuP,EAAS,UACjBa,MAAOA,EAAM,UACbK,OAAQzQ,EAAOyQ,OACfpC,UAAAA,IAEFR,kBACK8B,EAAM9B,cACT9G,UAAWmI,EAAsBlN,QACjCsD,QAAStF,EAAOsF,QAChBlJ,kBAAUyR,EAAa7L,gBAAb0O,EAAsBtU,SAChC4D,OAAQuP,EAAS,gBACjBa,MAAOA,EAAM,gBACbK,gBAAQ5C,EAAa7L,gBAAb2O,EAAsBF,OAC9BpC,UAAWE,IAEb1Q,cAAe0S,GACfnE,SAAUkE,OAGiF3C,yEI1UjG,iBAGMnD,IADFqD,mBAGK,CACL7D,cAJgBA,YAKhBhK,SAL6BA,OAM7B+J,aANqCA,WAOrCsE,YAPiDA,8BCIrD,SAAmBzO,EAAcgR,YAAAA,IAAAA,EAAuD,UAGlFpG,IADFxK,WAAUsF,QAAAA,aAAU,KAAI3I,IAAAA,SAGpB2F,EAASuK,WACb,kBAAMvH,EAAQhD,QAAO,SAACgB,UAAMA,aAAahC,GAAiBgC,EAAET,YAAcjD,KAAM,KAChF,QAGG0C,QACG,IAAItE,iBAAiB4B,6BAGWwO,WAAS9L,EAAO9F,OAAjDqU,OAAUC,OAEjBd,aAAU,eACFe,EAAiBzO,EAAOpH,OlBbK,qBkBa2B,WAC5D4V,EAAoBxO,EAAO9F,iBAGtB,WACLuU,OAED,UAU0DH,EAArDvF,KAAAA,aAAO,YAA8CuF,EAArCI,cAAAA,aAAyB,UAAT3F,UAyCjC,CACL3J,QAxC4BmL,WAAQ,eAC/BlQ,UAAYA,SAAAA,EAAUC,iBAClB,OAGH+J,EAAahK,EAAS+J,gBACtBuK,EAAmBtU,EAASiK,sBAC5BsK,EAAU5O,EAAOU,WACjBpB,EAAQU,EAAOS,cAEjBmO,GAAWtP,EAAO,KACdD,EAAQW,EAAOY,UACjBpB,EAAQ,QACTA,IAAWmP,GAAoB,IAAIrP,IAAU,IAA7CE,OACS,SACS6E,GAAc,IAAI/E,IAAU,IAA5CE,MAAAA,aAAQ,SAGPqP,EAAO/F,EAAU9N,OAAOC,QAAQuE,GAAQuJ,EAAM2F,GAEjD5N,KAAI,gBAAEgO,aAAqC,CAC1CA,MAAAA,EACAtP,WACAjC,MAAO8B,EAAWC,UAAawP,OAAexP,SAAYwP,iBAG9D9O,EAAOK,WAAWwO,EAAKzL,QAAO,SAACrH,EAAGgF,qBAAYhF,UAAIgF,EAAE+N,OAAQ/N,EAAExD,YAAU,KAEjEsR,SAGF/F,EAAU9N,OAAOC,QAAQ+E,EAAOW,cAAeoI,EAAM2F,GAAe5N,KAAI,gBAAEgO,aAIxE,CAAEA,MAAAA,EAAOvR,WAAOiC,eC1EEnF,EAA2BkD,qBACnDlD,UAAYA,SAAAA,EAAUC,kBAClB,SAGLkF,EAAiC,EAC/B6E,EAAahK,EAAS+J,gBACtBuK,EAAmBtU,EAASiK,6BAE9BqK,GAAoB3T,OAAOuB,uBAAKoS,EAAiBjL,gBAAjBqL,EAA0BvP,SAAS,IAAIG,SAASpC,GAC/EiC,EAAUmP,EAAiBjL,QAA3BlE,MACM6E,GAAcrJ,OAAOuB,uBAAK8H,EAAWX,gBAAXsL,EAAoBxP,SAAS,IAAIG,SAASpC,KAC1EiC,EAAU6E,EAAWX,QAArBlE,OAGDyP,WAASzP,GACJ,WAGDA,EAAMjC,MAAqB,EDqDjB2R,CAAe7U,EADfiD,MAAQwR,SAKvB,CAACnD,KAAKwD,gBAAU9U,SAAAA,EAAU4J,gBAI3BmL,YAnDkB,SAAC7R,EAAiBuC,YAAAA,IAAAA,GAAQ,GAC5CE,EAAOJ,IAAIrC,EAAOuC,IAmDlByO,SAAAA,EACA/M,MAjDY,WACZxB,EAAOwB,SAiDPrC,MAAOa,EAAOa,qDEpFlB,iBAGMqH,IADFxK,OAAUA,IAAAA,OAAQ+G,IAAAA,gBAWb,CAAE+C,QAXsBA,MAWf6H,SARCnB,eACf,SAACoB,GACC7K,EAAU7E,IAAI,CAAE0P,EAAAA,IAChB5R,EAAO4R,KAET,CAAC5R,EAAQ+G,6BCPb,SAAwBnH,SAGlB4K,IADFxK,WAAUsF,QAAAA,aAAU,KAAI3I,IAAAA,SAAUmN,IAAAA,MAG9B+H,EAAY7C,SAAsB,MAClC8C,EAAmB9C,UAAgB,GACnC1M,EAASuK,WACb,kBAAMvH,EAAQhD,QAAO,SAACgB,UAAMA,aAAaU,GAAsBV,EAAET,YAAcjD,KAAM,KACrF,IAEIkF,EAAcxC,EAAOwC,cACrBiN,EAAQzP,EAAOsC,gBAEhBtC,QACG,IAAItE,iBAAiB4B,6BAGKwO,WAAS9L,EAAO9F,OAA3C+H,OAAOyN,SACQ5D,WAAiB2D,EAAM,IAAtC7N,OAAKQ,SACU0J,WAAiB2D,EAAM,IAAtC5N,OAAKQ,OAEZqL,aAAU,WAEJlL,GAAqC,OAAtB+M,EAAU7P,SAC3BM,EAAOwB,OAAM,KAEd,CAACgG,IAEJkG,aAAU,eACFe,EAAiBzO,EAAOpH,OrBtBC,iBqBsB2B,WACxD8W,EAAiB1P,EAAO9F,iBAGnB,WACLuU,OAED,QAEGkB,EAAWjF,eAAY,SAACnN,GAC5ByC,EAAOJ,IAAIrC,KACV,IAEGqS,EAAYrF,WAAQ,mBACnBtI,IAGDO,EACKP,EAAM,KAAOL,GAAOK,EAAM,KAAOJ,EAGnC7B,EAAOyC,gBACb,CAACR,EAAOL,EAAKC,WAUhB6L,aAAU,cACHlL,GAAe+M,EAAU7P,UAAY8H,OAKrCnN,UAAYA,SAAAA,EAAUC,kBACzB8H,EAAOH,EAAQA,EAAM,GAAKwN,EAAM,IAChCpN,EAAOJ,EAAQA,EAAM,GAAKwN,EAAM,SAChCD,EAAiB9P,SAAU,OAIvBJ,EAAQU,EAAOS,WACf4D,EAAahK,EAAS+J,gBACtBuK,EAAmBtU,EAASiK,sBAC9BuL,EAAS,EACTC,EAAS,EACPnO,GAAa0C,GAAc,IAAI/E,IAAU,GACzCyQ,GAAmBpB,GAAoB,IAAIrP,IAAU,GAEtD0Q,oBAAkBD,EAAgBnO,KAE3BoO,oBAAkBrO,EAAUC,OACtCiO,EAASlO,EAAUC,KAFnBiO,EAASE,EAAgBnO,IAKtBoO,oBAAkBD,EAAgBlO,KAE3BmO,oBAAkBrO,EAAUE,OACtCiO,EAASnO,EAAUE,KAFnBiO,EAASC,EAAgBlO,UAKR7B,EAAO0C,OAAO,CAACmN,EAAQC,IAAjCA,OAET1N,EAFCyN,QAGDxN,EAAOyN,GAGP9P,EAAOoC,OAAOyN,GACd7P,EAAOqC,OAAOyN,GAEd9P,EAAOJ,IAAI,CAACiQ,EAAQC,IAAS,GAC7BJ,EAAiB,CAACG,EAAQC,IAE1BP,EAAU7P,QAAU8H,OA3ClB+H,EAAU7P,QAAU8H,IA4CrB,CAACmE,KAAKwD,gBAAU9U,SAAAA,EAAU4J,gBAEtB,CACLrC,IAAAA,EACAC,IAAAA,EACAC,KAAM9B,EAAOuC,UACboN,SAAAA,EACA1N,MAAAA,EACAT,MA9DY,WACRgB,EACFxC,EAAOJ,cAAQI,EAAOsC,cAEtBtC,EAAOwB,SA2DToO,UAAAA,8BCtHJ,iBAOM1H,IALFxK,OACEA,IAAAA,OACUnF,IAAVmN,OAAUnN,oBACVkM,IAAAA,UAIEwL,EAAoB/B,eACxB,SAACgC,SACCzL,EAAU7E,YAAOrH,GAAsB2X,MACvCxS,MAEF,CAAC+G,EAAW/G,IAGRuM,EAAiBD,SAASvF,EAAUvK,MAAM3B,GAAsB,UAE/D,CACL0R,eAAgBgF,WAAShF,GAAkBA,EAAiB,GAC5DgG,kBAAAA,sBCiFJ,SAAmB3B,SACK,iBAAXA,GAAuB,aAAcA,GAAU,cAAeA,GApGhDxU,KAqGAwU,GArGAxU,SAAU2K,IAAAA,UAC5BsH,KAA2BD,YAAS,OAAzBE,OACZiB,EAAWvC,eACf,SAAC4E,SACCtD,GAAa,GAEH,KAANsD,EACFxV,EAAS8M,cAAcnC,EAAUvK,QAE7BoV,GACF7K,EAAU7E,YAAOzH,EAAcC,QAASkX,MAE1CxV,EAAS4D,OAAO+G,EAAUvK,UAG9B,CAACJ,EAAU2K,IAGN0L,KAAiCrE,WAA6C,CACnFpO,OAAQuP,EACRtT,MAAO,WAFYyW,OAKrB1C,aAAU,kBACRT,IAEOnT,EAASlB,OvBlCkB,oBuBkCa,SAACyB,GAC9C2R,GAAa,GAEboE,GAAgB,SAACC,eACZA,GACHC,cAASjW,SAAAA,EAAU4J,aACnBsM,cAASlW,SAAAA,EAAU8J,UACnB+F,mBAAc7P,SAAAA,EAAU6J,kBACxBvK,YAAOU,SAAAA,EAAU0J,qBAGpB,IAEH2J,aACE,kBACEjJ,EAAU7L,OvB9CoB,kBuB8CS,WACrCqU,SAEJ,SAGUkD,GAAcpE,UAAAA,KAG5B,gBAA2ByE,IAAAA,kBAAeC,iBAAAA,kBACd3E,WAAuB,MAA1CnS,OAAO+W,SAIVxI,QAFFxK,OAAUqO,IAAAA,UAAW1R,IAAAA,SAAUqD,IAAAA,WAC/B6N,aAAwBoF,IAARjT,OAAyBgK,IAAAA,YAGrC4I,QAAUjW,SAAAA,EAAU4J,aACpB2M,EAAgBlG,eAAY,SAAC4E,UAAcqB,EAAgBrB,KAAI,WAErE5B,aAAU,gBACc/P,IAAlB6S,GACEC,GAAsC,KAAlBD,IACtB9S,EAAO8S,GAGT9S,MAED,CAAC8S,IAEJ9C,aAAU,sBACJrT,UACM,QACDA,EAASE,UACZmW,oBAASrW,EAAS0J,mBAAT8M,EAAqBlX,SAAS,IAAI+B,MAAM,uDAG7CrB,EAASE,UACbmW,EAAS,SAOd,CAACrW,IAEG,CACLkW,cAASlW,SAAAA,EAAU8J,UACnB+F,mBAAc7P,SAAAA,EAAU6J,kBACxBwD,kBAAaA,EAAAA,EAAe,GAC5B4I,QAAAA,EACA5S,OAAAA,EACAkT,cAAAA,EACA7E,UAAAA,EACApS,MAAAA,GASKmX,OAAgBxC,EAAAA,EAAU,IAxGnC,MAA2BxU,EAAU2K,IAC5BsH,EAAWC,EACZiB,IAgBCkD,EAAcC,4BCpBvB,iBCNiEtP,EACzDiQ,IDQF7I,IADFxK,OAAUgI,IAAAA,OAAQrL,IAAAA,SAAUqD,IAAAA,OAAQqO,IAAAA,cAAWoC,OAAAA,aAAS,KAAIL,IAAAA,QAEKlE,EAAc,UAAzEG,IAAAA,KAAME,IAAAA,eAAgBC,IAAAA,aAAcU,IAAAA,UAAWC,IAAAA,QACjDmG,GCXyDlQ,QDW/BzG,SAAAA,EAAU2J,cCVpC+M,EAAM,GACRjQ,GACFA,EAAIvH,SAAQ,SAAC0G,EAAGgR,GACG,iBAANhR,GAA+B,iBAANA,IAClC8Q,EAAIE,GAAKhR,MAKR8Q,GDEDT,QAAUjW,SAAAA,EAAU4J,mBAEnB,CACLiN,qBAAO7W,SAAAA,EAAUC,cACjBX,YAAOU,SAAAA,EAAU0J,WACjBD,kBAAazJ,SAAAA,EAAUI,iBACvB8V,cAASlW,SAAAA,EAAU8J,UACnB4F,KAAAA,EACAE,eAAAA,EACAC,aAAAA,EACAU,UAAAA,EACAC,QAAAA,EACAnN,OAAAA,EACA4S,QAAAA,EACAjW,SAAU2W,EACVjF,UAAAA,EACAoF,UAAWnB,oBAAkBM,GAC7BnC,OAAAA,EACAzI,OAAAA,EACAoI,MAAAA,uBE3BJ,mBAGM5F,IADFxK,OAAUA,IAAAA,OAAQ+G,IAAAA,UAGd2M,EAAa1G,eACjB,SAAC2G,GACC5M,EAAU7E,IAAI,CAAEmJ,KAAMsI,IACtB3T,MAEF,CAAC+G,EAAW/G,UAGP,CACL4T,iBAAS7M,EAAUvK,MAAM6O,QAAQ,GACjCqI,WAAAA,wBCjBJ,iBAIMlJ,IAFF3M,IAAAA,oBAIK,CACLgW,0BAJA7T,OAAU5D,SAEYgN,YAEU0K,mBAChCvD,oBAAqB1S,yBCRzB,iBAIS,CAAEkJ,UADLyD,IADFxK,OAAU+G"}