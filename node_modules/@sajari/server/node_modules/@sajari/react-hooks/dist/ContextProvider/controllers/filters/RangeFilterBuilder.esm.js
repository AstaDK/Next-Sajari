import { isArray, roundToStep } from '@sajari/react-sdk-utils';
import { EVENT_RANGE_UPDATED } from '../../events.esm.js';
import { Listener } from '../Listener.esm.js';

var events = [EVENT_RANGE_UPDATED];

var RangeFilterBuilder = /*#__PURE__*/function () {
  function RangeFilterBuilder(_ref) {
    var _this$listeners;

    var field = _ref.field,
        name = _ref.name,
        group = _ref.group,
        _ref$aggregate = _ref.aggregate,
        aggregate = _ref$aggregate === void 0 ? true : _ref$aggregate,
        initial = _ref.initial,
        _ref$min = _ref.min,
        min = _ref$min === void 0 ? 0 : _ref$min,
        _ref$max = _ref.max,
        max = _ref$max === void 0 ? aggregate ? 0 : 100 : _ref$max,
        _ref$step = _ref.step,
        step = _ref$step === void 0 ? 1 : _ref$step,
        _ref$formatter = _ref.formatter,
        formatter = _ref$formatter === void 0 ? function (value) {
      return value.map(function (v) {
        return roundToStep(v, step);
      });
    } : _ref$formatter;

    if (typeof initial === 'undefined') {
      this.initial = aggregate ? null : [min, max];
    } else {
      this.initial = initial;
    }

    this.range = this.initial;
    this.name = name;
    this.group = group;
    this.field = field;
    this.formatter = formatter;
    this.min = min;
    this.max = max;
    this.step = step;
    this.aggregate = aggregate;
    this.listeners = (_this$listeners = {}, _this$listeners[EVENT_RANGE_UPDATED] = new Listener(), _this$listeners);
  }

  var _proto = RangeFilterBuilder.prototype;

  _proto.listen = function listen(event, callback) {
    if (!events.includes(event)) {
      throw new Error("Unknown event type \"" + event + "\"");
    }

    return this.listeners[event].listen(callback);
  };

  _proto.get = function get() {
    return this.range;
  };

  _proto.set = function set(range, emitEvent) {
    if (emitEvent === void 0) {
      emitEvent = true;
    }

    this.range = range ? this.formatter(range) : range;

    if (emitEvent) {
      this.emitRangeUpdated();
    }
  };

  _proto.getName = function getName() {
    return this.name;
  };

  _proto.getGroup = function getGroup() {
    return this.group;
  };

  _proto.getField = function getField() {
    return this.field;
  };

  _proto.setMin = function setMin(value) {
    this.min = value;
  };

  _proto.setMax = function setMax(value) {
    this.max = value;
  };

  _proto.getMinMax = function getMinMax() {
    return [this.min, this.max];
  };

  _proto.getStep = function getStep() {
    return this.step;
  };

  _proto.filter = function filter() {
    if (!this.range) {
      return '';
    }

    return this.field + " >= " + this.range[0] + " AND " + this.field + " <= " + this.range[1];
  };

  _proto.isAggregate = function isAggregate() {
    return this.aggregate;
  };

  _proto.hasChanged = function hasChanged() {
    if (!this.range || !this.initial) {
      return this.range === this.initial;
    }

    return this.range[0] !== this.initial[0] || this.range[1] !== this.initial[1];
  };

  _proto.reset = function reset(emitEvent) {
    if (emitEvent === void 0) {
      emitEvent = true;
    }

    this.range = isArray(this.initial) ? [].concat(this.initial) : this.initial;

    if (emitEvent) {
      this.emitRangeUpdated();
    }
  };

  _proto.format = function format(value) {
    return this.formatter(value);
  };

  _proto.emitRangeUpdated = function emitRangeUpdated() {
    var _this = this;

    this.listeners[EVENT_RANGE_UPDATED].notify(function (listener) {
      listener(_this);
    });
  };

  return RangeFilterBuilder;
}();

export default RangeFilterBuilder;
//# sourceMappingURL=RangeFilterBuilder.esm.js.map
